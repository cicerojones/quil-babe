*  Oh, do ~:reload~ my friends
** first passes
*** deal with namespaces
  :PROPERTIES:
  :ID:       BD6805C4-0991-4002-98FD-E0AF86528FA2
  :END:
#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.core)
#+end_src

#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.dynamic)
#+end_src

#+begin_src clojure :show-process t
(in-ns 'quilbabel.dynamic)
#+end_src
*** versions of draw
**** Version currently in core:

Colored "rim" and greyscaled "center"

#+begin_src clojure :show-process t
(defn draw []
  (q/stroke (q/random 255) (q/random 255) (q/random 255))
  (q/fill (q/random 255))
  (let [diam (q/random 100)
        x    (q/random (q/width))
        y    (q/random (q/height))]
    (q/ellipse x y diam diam)))
#+end_src

#+begin_src clojure :show-process t
(in-ns 'quilbabel.dynamic)
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

Without changing namespace in the REPL!!
: #namespace[quilbabel.core]


Must eval the namespace change in the REPL?
**** Black and white version with "proper" ellipses
#+begin_src clojure :show-process t
  (defn draw []
    (q/stroke (q/random 255))
    (q/stroke-weight (q/random 10))
    (q/fill (q/random 255))
    (let [diam (q/random 100)
	  x    (q/random (q/width))
	  y    (q/random (q/height))]
      (q/ellipse x y (* 2 diam) diam)))
#+end_src

#+RESULTS:
: #'quilbabel.core/draw


Now, you need not even reload!! Just eval the block
**** Color version:
#+begin_src clojure :show-process t
  (defn draw []
    (q/stroke (q/random 255) (q/random 255) (q/random 255))
    (q/stroke-weight (q/random 10))
    (q/fill (q/random 255))

    (let [diam (q/random 100)
	  x (q/random (q/width))
	  y (q/random (q/height))]
      (q/ellipse x y diam diam)))

#+end_src

#+RESULTS:
: #'quilbabel.dynamic/draw

** quil-sketches.mouse
*** original as one block (~quil-sketches.mouse~ namespace)
#+begin_src clojure :show-process t
(ns quil-sketches.mouse
  (:require [quil.core :refer :all]))

(defn setup []
  (smooth)
  (no-stroke)
  (set-state! :mouse-position (atom [0 0])))

(defn draw
  []
  (background-float 125)
  (stroke-weight 20)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))

(defn mouse-moved []
  (let [x (mouse-x)  y (mouse-y)]
    (reset! (state :mouse-position) [x y])))

(defsketch mouse-example
  :title "Mouse example."
  :size [200 200]
  :setup setup
  :draw draw
  :mouse-moved mouse-moved)

(defn -main [& args])
#+end_src

*** use tangling to dynamically add code to project?
Here is the code copied straight from the quil-examples into a babel block

Note that I use a tangle argument to create this file in the src directory of this project

This is just to make sure I can get the basic thing working before moving on to a dynamic workflow.
#+begin_src clojure :show-process t :tangle "src/quilbabel/mousebabel.clj"
(ns quilbabel.mousebabel
  (:require [quil.core :refer :all]))

(defn setup []
  (smooth)
  (no-stroke)
  (set-state! :mouse-position (atom [0 0])))

(defn draw
  []
  (background-float 125)
  (stroke-weight 20)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))

(defn mouse-moved []
  (let [x (mouse-x)  y (mouse-y)]
    (reset! (state :mouse-position) [x y])))

(defsketch mouse-example
  :title "Mouse example."
  :size [200 200]
  :setup setup
  :draw draw
  :mouse-moved mouse-moved)

;; (defn -main [& args])

#+end_src

Will reload sketch the whole, original version of the sketch
#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.mousebabel)
#+end_src
*** break up namespace
Now get ready to tangle two files, one for the core defsketch and one for the setup and draw, so that you can use the latter to dynamically reload the changes from babel
**** core
#+begin_src clojure :show-process t :tangle "src/quilbabel/mousebabelcore.clj"
(ns quilbabel.mousebabel
(:require [quil.core :refer :all])
(:require [quilbabel.mousebabeldynamic :as dynamic]))

(defsketch mouse-example
  :title "Mouse example."
  :size [200 200]
  :setup dynamic/setup
  :draw dynamic/draw
  :mouse-moved dynamic/mouse-moved)

#+end_src
**** dynamic
#+begin_src clojure :show-process t :tangle "src/quilbabel/mousebabeldynamic.clj"
(ns quilbabel.mousebabeldynamic
  (:require [quil.core :refer :all]))

(defn setup []
  (smooth)
  (no-stroke)
  (set-state! :mouse-position (atom [0 0])))

(defn draw
  []
  (background-float 125)
  (stroke-weight 20)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))

(defn mouse-moved []
  (let [x (mouse-x)  y (mouse-y)]
    (reset! (state :mouse-position) [x y])))
#+end_src
**** reload
#+begin_src clojure :show-process t
(use :reload 'quilbabel.mousebabelcore)
#+end_src

#+RESULTS:
: nil
**** Use the ~in-ns~ command in the REPL
#+BEGIN_SRC clojure :show-process t

(in-ns 'quilbabel.mousebabeldynamic)
#+END_SRC

Check that the change took hold here in babel-land.
#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.mousebabeldynamic]
**** Change the draw function 
#+begin_src clojure :show-process t
(defn draw
  []
  (background-float 125)
  (stroke-weight 2)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))
#+end_src

#+RESULTS:
: #'quilbabel.mousebabeldynamic/draw

** functional mode using babel
*** original as one block

Use the repl to call "use" the "namespace/file" you create here:

(DON'T FORGET TO CHANGE THE NAMESPACE TO MATCH THE FILE!
#+begin_src clojure :show-process t :tangle "src/quilbabel/funbabel.clj"
(ns quilbabel.funbabel
  (:require [quil.core :as q]
            [quil.middleware :as m]))

(def min-r 10)

(defn setup []
  ; initial state
  {:x 0 :y 0 :r min-r
   }
  )

(defn my-update [state]
  ; increase radius of the circle by 1 on each frame
  (update-in state [:r] inc))

(defn draw [state]
  (q/background 255)
  (q/ellipse (:x state) (:y state) (:r state) (:r state)))

; decrease radius by 1 but keeping it not less than min-r
(defn shrink [r]
  (max min-r (dec r)))

(defn mouse-moved [state event]
  (-> state
      ; set circle position to mouse position
      (assoc :x (:x event) :y (:y event))
      ; decrease radius
      (update-in [:r] shrink)))

(q/defsketch fun-mode-example
  :size [200 200]
  :setup setup
  :draw draw
  :update my-update
  :mouse-moved mouse-moved
  :middleware [m/fun-mode])

#+end_src

Can I dynamically
#+begin_src clojure :show-process t :results silent
(def min-r 30)
#+end_src

#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

#+begin_src clojure :show-process t
(use :reload 'quilbabel.funbabel)
#+end_src

#+RESULTS:
: nil
* changing frame rates dynamically?

Will run the sketch ~quil-example~ in quilbabel/src/quilbabel/core.clj
#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.core)
#+end_src

Now, copy this to the REPL in order to get define functions that use the "dynamic" namespace
#+begin_src clojure :show-process t
(in-ns 'quilbabel.dynamic)
#+end_src

But, no matter how much you want to change the frame-rate from setup, it appears that this is already done
#+begin_src clojure :show-process t
(defn setup []
  (q/frame-rate 10))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/setup
* use anonymous functions in defsketch for quick experiments
  :PROPERTIES:
  :ID:       828D0FC4-0291-4FE4-B457-CF3DD7864E27
  :END:
** concentrate circles in the top corner
#+begin_src clojure :show-process t :results silent
  (q/defsketch ellipses-with-fn-literals1
    :setup #(q/frame-rate 10)
    :draw #(q/ellipse (q/random 100) (q/random 100) 10 10)
	       )
#+end_src

#+RESULTS:
: #'my-simple-enlive.core/ellipses-with-fn-literals1
** use a ~do~ block to run two different drawings concurrent
#+begin_src clojure :show-process t
  (q/defsketch ellipses-with-fn-literals2
    :setup #(q/frame-rate 30)
    :draw #(do (q/ellipse (q/random 100) (q/random 100) 10 10)
	       ;; (Thread/sleep 3000)
	       (q/ellipse (q/random 100 300) (q/random 100 300) 10 10)
  ))

#+end_src

#+RESULTS:
: #'quilbabel.dynamic/allthree
** draw single pixel circles next to 10 pixel circles
#+begin_src clojure :show-process t
  (q/defsketch ellipses-with-fn-literals3
    :setup #(q/frame-rate 30)
    :draw #(do (q/ellipse (q/random 100) (q/random 100) (q/random 1 3) (q/random 1 3))
	       ;; (Thread/sleep 3000)
	       (q/ellipse (q/random 100 300) (q/random 100 300) 10 10)
  ))

#+end_src

#+RESULTS:
: #'quilbabel.dynamic/allthree
** nest anonymous functions, but not function literals (esp. without arguments!)
#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.core]

#+begin_src clojure :show-process t
(q/defsketch drawcircles-with-fun-mode
:size[480 120]
:setup (fn [] {:x 0, :y 0, :r 10})
:draw #(q/ellipse (:x %) (:y %) (:r %) (:r %))
:update #(update-in % [:r] inc)
:mouse-moved (fn [m e] (-> m (assoc :x (:x e) :y (:y e)) (update-in [:r] #(max 10 (dec %)))))
:middleware [m/fun-mode])
#+end_src

#+RESULTS:
: #'quilbabel.core/drawcircles

FAILS
#+begin_src clojure :show-process t
;; fails because no "draw"?
(q/defsketch diagonals
:size [480 120]
:setup (fn [] (do (q/stroke-weight 8) (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals

#+begin_src clojure :show-process t
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/stroke-weight 8)
:draw #(q/line 10 40 (+ 10 60) 80)
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals1

** use dorun
FAILS
#+begin_src clojure :show-process t
;; fails because lazy-seq ~for~
(q/defsketch diagonals
:size [480 120]
:setup #(q/stroke-weight 8)
:draw #(for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals

#+begin_src clojure :show-process t
;; succeeds with DORUN
(q/defsketch diagonals2
:size [480 120]
:setup #(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80)))
)
#+end_src
#+RESULTS:
: #'quilbabel.core/diagonals2

#+begin_src clojure :show-process t
;; succeeds with DORUN
(q/defsketch diagonals3
:size [480 120]
:setup #(do (q/stroke-weight 8) (dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
)
#+end_src

** use setup with ~random~ values
#+RESULTS:
: #'quilbabel.core/diagonals3
#+begin_src clojure :show-process t :results silent
;; stroke-weight set just once
(q/defsketch diagonals3
:size [480 120]
:setup #(do (q/stroke-weight (rand-int 8)) (dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals3

#+begin_src clojure
;; captures same stroke-weight 
(q/defsketch diagonals3
:size [480 120]
:draw #(dorun (for [n (range 20 400 60)] (do (q/stroke-weight (rand-int 34)) (q/line n 40 (+ n 60) 80))))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

#+begin_src clojure
;; use overtone function
;; when used with ~:draw~ runs through all rand n?
  (q/defsketch diagonals3
    :size [480 120]
    :draw #(let [x (overtone.algo.chance/weighted-choose [1 20 40 90] [0.5 0.3 0.125 0.075])]
	    (do (q/stroke-weight (rand-int x))
		(q/line 10 40 (+ 10 50) 80))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3


#+begin_src clojure
;; when used with ~:setup~ get different behavior
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(let [x (overtone.algo.chance/weighted-choose [10 20 40 90] [0.5 0.3 0.125 0.075])]
	    (do (q/stroke-weight (rand-int x))
		(q/line 10 40 (+ 10 50) 80))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

** use ~dorun~ in a setup function
#+begin_src clojure
;; use setup with dorun
(q/defsketch diagonals3
:size [480 120]
:setup #(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

#+begin_src clojure
;; proper use of ~for~ loop with ~do~ block?!
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(dorun (for [n (range 20 400 60)]
		     (do (let [x (overtone.algo.chance/weighted-choose [10 20 40 90] [0.5 0.3 0.125 0.075])]
			   (q/stroke-weight (rand-int x))
			   (q/line n 40 (+ n 60) 80))))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

** primitive ~overtone~ call in a quil ~sketch~
#+begin_src clojure
((overtone.live/synth (overtone.live/out 0 (overtone.live/sin-osc))))
#+end_src

#+RESULTS:
: #<synth-node[loading]: quilbabel.dynamic/anon-3 39>

#+begin_src clojure
(overtone.live/kill 39)
#+end_src

#+RESULTS:
: nil

#+begin_src clojure
  ;; proper use of ~for~ loop with ~do~ block?!
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(dorun (for [n (range 20 400 60)]
		     (do (let [x (overtone.algo.chance/weighted-choose [10 20 40 90] [0.5 0.3 0.125 0.075])]
			   (q/stroke-weight (rand-int x))
			   ((overtone.live/synth (overtone.live/out 0 (overtone.live/sin-osc (+ (rand-nth [100 300 500]) (* 10 (rand) ))))))
			   (q/line n 40 (+ n 60) 80))))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

** save a frame?
Without an argument...

/Users/ao/scratch/quilbabel/screen-0000.tif

#+begin_src clojure :show-process t
;; writes to wherever notion of "current directory" is
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(do (q/stroke-weight (rand-int 8))
		(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80)))
		(q/save-frame)
    ))
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals3

#+begin_src clojure
  ;; stroke-weight set just once
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(do (q/stroke-weight (rand-int 8))
		(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80)))
		(q/save-frame "./resources/lines1.jpg")
    ))
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals3

#+begin_src clojure :results output
(clojure.repl/doc q/save-frame)
#+end_src

#+RESULTS:
#+begin_example
-------------------------
quil.core/save-frame
([] [name])
  Saves an image identical to the current display window as a
  file. May be called multple times - each file saved will have a
  unique name. Name and image formate may be modified by passing a
  string parameter of the form "foo-####.ext" where foo- can be any
  arbitrary string, #### will be replaced with the current frame id
  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg

  Examples:
  (save-frame)
  (save-frame "pretty-pic-####.jpg")
#+end_example

** translating arbitrary GSWP code
#+begin_src processing
size(480, 120);
noStroke();
background(204, 226, 225);    // Light blue color
fill(255, 0, 0, 160);         // Red color
ellipse(132, 82, 200, 200);   // Red circle
fill(0, 255, 0, 160);         // Green color
ellipse(228, -16, 200, 200);  // Green circle
fill(0, 0, 255, 160);         // Blue color
ellipse(268, 118, 200, 200);  // Blue circle

#+end_src

#+begin_src clojure :results silent
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(do (q/no-stroke)
(q/background 204, 226, 225)
(q/fill 255, 0, 0, 160)
(q/ellipse 132, 82, 200, 200)
(q/fill 0, 255, 0, 160)
(q/ellipse 228, -16, 200, 200)
(q/fill 0, 0, 255, 160)
(q/ellipse 268, 118, 200, 200)
;; save-frame?
;; (q/save-frame "./resources/colors1.jpg")
    ))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

* testing misc. clojure blocks
#+begin_src clojure
(for [n (range 5)] (rand-int 8))
#+end_src

#+RESULTS:
| 6 | 7 | 5 | 6 | 4 |


#+begin_src clojure
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

#+begin_src clojure :results output
(clojure.repl/dir quilbabel.dynamic)
#+end_src

#+RESULTS:
: diagonals3
: draw
: setup

Pretty-print! (an impressively long and vaguely helpful list)
#+begin_src clojure :results value pp
(loaded-libs)
#+end_src

#+RESULTS:
#+begin_example
#{cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.complete
  cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.info
  cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.util.analysis
  cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.util.misc
  cider.inlined-deps.compliment.v0v3v4.compliment.context
  cider.inlined-deps.compliment.v0v3v4.compliment.core
  cider.inlined-deps.compliment.v0v3v4.compliment.sources
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.class-members
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.keywords
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.local-bindings
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.namespaces-and-classes
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.ns-mappings
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.resources
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.special-forms
  cider.inlined-deps.compliment.v0v3v4.compliment.utils
  cider.inlined-deps.javaclasspath.v0v2v3.clojure.java.classpath
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.dependency
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.file
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.find
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.parse
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.track
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.default-data-readers
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.impl.commons
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.impl.utils
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.reader-types
  cider.nrepl cider.nrepl.middleware.complete
  cider.nrepl.middleware.debug cider.nrepl.middleware.info
  cider.nrepl.middleware.inspect cider.nrepl.middleware.ns
  cider.nrepl.middleware.out cider.nrepl.middleware.pprint
  cider.nrepl.middleware.stacktrace cider.nrepl.middleware.track-state
  cider.nrepl.middleware.util.cljs
  cider.nrepl.middleware.util.error-handling
  cider.nrepl.middleware.util.inspect
  cider.nrepl.middleware.util.instrument
  cider.nrepl.middleware.util.java
  cider.nrepl.middleware.util.java.parser
  cider.nrepl.middleware.util.meta cider.nrepl.middleware.util.misc
  cider.nrepl.middleware.util.namespace
  cider.nrepl.middleware.util.spec cider.nrepl.print-method
  cider.nrepl.version clj-native.callbacks clj-native.direct
  clj-native.direct-util clj-native.functions clj-native.structs
  clj-native.unions clojure.core.protocols clojure.core.server
  clojure.data.json clojure.edn clojure.instant clojure.java.browse
  clojure.java.io clojure.java.javadoc clojure.java.shell clojure.main
  clojure.pprint clojure.reflect clojure.repl clojure.set
  clojure.stacktrace clojure.string clojure.template clojure.test
  clojure.tools.nrepl clojure.tools.nrepl.ack
  clojure.tools.nrepl.bencode clojure.tools.nrepl.middleware
  clojure.tools.nrepl.middleware.interruptible-eval
  clojure.tools.nrepl.middleware.load-file
  clojure.tools.nrepl.middleware.pr-values
  clojure.tools.nrepl.middleware.session clojure.tools.nrepl.misc
  clojure.tools.nrepl.server clojure.tools.nrepl.transport clojure.uuid
  clojure.walk clojure.zip complete.core dynapath.defaults
  dynapath.dynamic-classpath dynapath.util org.satta.glob
  overtone.algo.chance overtone.algo.fn overtone.algo.lists
  overtone.algo.scaling overtone.algo.trig overtone.api overtone.at-at
  overtone.byte-spec overtone.config.file-store overtone.config.log
  overtone.config.store overtone.helpers.audio-file
  overtone.helpers.doc overtone.helpers.file overtone.helpers.hash
  overtone.helpers.lib overtone.helpers.map overtone.helpers.math
  overtone.helpers.ns overtone.helpers.old-contrib overtone.helpers.ref
  overtone.helpers.seq overtone.helpers.stereo overtone.helpers.string
  overtone.helpers.synth overtone.helpers.system overtone.helpers.zip
  overtone.jna-path overtone.libs.app-icon overtone.libs.asset
  overtone.libs.asset.store overtone.libs.boot-msg
  overtone.libs.counters overtone.libs.deps overtone.libs.event
  overtone.libs.handlers overtone.live overtone.midi
  overtone.music.pitch overtone.music.rhythm overtone.music.time
  overtone.music.tuning overtone.nativescsynth.availability
  overtone.osc overtone.osc.decode overtone.osc.dyn-vars
  overtone.osc.encode overtone.osc.pattern overtone.osc.peer
  overtone.osc.util overtone.repl.debug overtone.repl.examples
  overtone.repl.graphviz overtone.repl.inst overtone.repl.shell
  overtone.repl.ugens overtone.samples.freesound
  overtone.samples.freesound.search-results
  overtone.samples.freesound.url overtone.sc.bindings
  overtone.sc.buffer overtone.sc.bus overtone.sc.cgens.audio-in
  overtone.sc.cgens.beq-suite overtone.sc.cgens.berlach
  overtone.sc.cgens.bhob overtone.sc.cgens.buf-io
  overtone.sc.cgens.demand overtone.sc.cgens.dyn overtone.sc.cgens.env
  overtone.sc.cgens.freq overtone.sc.cgens.fx overtone.sc.cgens.info
  overtone.sc.cgens.io overtone.sc.cgens.line overtone.sc.cgens.mix
  overtone.sc.cgens.oscillators overtone.sc.cgens.tap overtone.sc.clock
  overtone.sc.defaults overtone.sc.defcgen overtone.sc.dyn-vars
  overtone.sc.envelope overtone.sc.example
  overtone.sc.examples.audio-in overtone.sc.examples.blackrain
  overtone.sc.examples.compander overtone.sc.examples.demand
  overtone.sc.examples.dyn overtone.sc.examples.membrane
  overtone.sc.examples.osc overtone.sc.examples.trig
  overtone.sc.examples.vosim overtone.sc.foundation-groups
  overtone.sc.info overtone.sc.machinery.allocator
  overtone.sc.machinery.defexample overtone.sc.machinery.server.args
  overtone.sc.machinery.server.comms
  overtone.sc.machinery.server.connection
  overtone.sc.machinery.server.native
  overtone.sc.machinery.server.osc-validator
  overtone.sc.machinery.synthdef overtone.sc.machinery.ugen.categories
  overtone.sc.machinery.ugen.check overtone.sc.machinery.ugen.common
  overtone.sc.machinery.ugen.defaults overtone.sc.machinery.ugen.doc
  overtone.sc.machinery.ugen.fn-gen
  overtone.sc.machinery.ugen.intern-ns
  overtone.sc.machinery.ugen.metadata.basicops
  overtone.sc.machinery.ugen.metadata.beq-suite
  overtone.sc.machinery.ugen.metadata.binaryopugen
  overtone.sc.machinery.ugen.metadata.buf-io
  overtone.sc.machinery.ugen.metadata.chaos
  overtone.sc.machinery.ugen.metadata.compander
  overtone.sc.machinery.ugen.metadata.control
  overtone.sc.machinery.ugen.metadata.delay
  overtone.sc.machinery.ugen.metadata.demand
  overtone.sc.machinery.ugen.metadata.envgen
  overtone.sc.machinery.ugen.metadata.extras.ay
  overtone.sc.machinery.ugen.metadata.extras.bat
  overtone.sc.machinery.ugen.metadata.extras.bbcut2u
  overtone.sc.machinery.ugen.metadata.extras.berlach
  overtone.sc.machinery.ugen.metadata.extras.bhob
  overtone.sc.machinery.ugen.metadata.extras.blackrain
  overtone.sc.machinery.ugen.metadata.extras.distortion
  overtone.sc.machinery.ugen.metadata.extras.glitch
  overtone.sc.machinery.ugen.metadata.extras.mda
  overtone.sc.machinery.ugen.metadata.extras.membrane
  overtone.sc.machinery.ugen.metadata.extras.sl
  overtone.sc.machinery.ugen.metadata.extras.stk
  overtone.sc.machinery.ugen.metadata.extras.tju
  overtone.sc.machinery.ugen.metadata.extras.vbap
  overtone.sc.machinery.ugen.metadata.extras.vosim
  overtone.sc.machinery.ugen.metadata.ff-osc
  overtone.sc.machinery.ugen.metadata.fft
  overtone.sc.machinery.ugen.metadata.fft-unpacking
  overtone.sc.machinery.ugen.metadata.fft2
  overtone.sc.machinery.ugen.metadata.filter
  overtone.sc.machinery.ugen.metadata.grain
  overtone.sc.machinery.ugen.metadata.info
  overtone.sc.machinery.ugen.metadata.input
  overtone.sc.machinery.ugen.metadata.io
  overtone.sc.machinery.ugen.metadata.line
  overtone.sc.machinery.ugen.metadata.machine-listening
  overtone.sc.machinery.ugen.metadata.misc
  overtone.sc.machinery.ugen.metadata.noise
  overtone.sc.machinery.ugen.metadata.osc
  overtone.sc.machinery.ugen.metadata.pan
  overtone.sc.machinery.ugen.metadata.random
  overtone.sc.machinery.ugen.metadata.trig
  overtone.sc.machinery.ugen.metadata.unaryopugen
  overtone.sc.machinery.ugen.sc-ugen
  overtone.sc.machinery.ugen.special-ops
  overtone.sc.machinery.ugen.specs overtone.sc.node
  overtone.sc.protocols overtone.sc.sample overtone.sc.server
  overtone.sc.synth overtone.sc.trig overtone.sc.ugens overtone.sc.util
  overtone.sc.vbap overtone.speech overtone.studio.core
  overtone.studio.fx overtone.studio.inst overtone.studio.midi
  overtone.studio.midi-player overtone.studio.mixer
  overtone.studio.scope overtone.studio.util overtone.studio.wavetable
  overtone.version quil.applet quil.core quil.helpers.applet-listener
  quil.helpers.docs quil.middleware quil.middlewares.bind-output
  quil.middlewares.deprecated-options quil.middlewares.fun-mode
  quil.middlewares.navigation-2d quil.middlewares.navigation-3d
  quil.middlewares.pause-on-error quil.middlewares.safe-fns quil.sketch
  quil.util quilbabel.core quilbabel.dynamic}
#+end_example

* Processing translation
README of processing-examples
[[file:~/org/secondary/processing-examples/README.org::*babel%20sandbox][babel sandbox]]

* text and typography practice

** simplest
#+begin_src clojure :results silent
(q/defsketch texty
:size [480, 120]
:setup #(q/text-font (q/create-font "data/Trattatello.ttf" 24))
:draw #(do (q/text-size 48) (q/text "YO Adrian" 100, 50))
  )
#+end_src
** use Letter.pde model from Processing Basics
#+begin_src clojure :results silent
  (q/defsketch texty
    :size [640, 360]

    :setup #(do (q/background 0)
		(q/text-font
		 (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(q/text-align :center, :center))
    :draw #(dorun 
	    (let [counter 35]
	      (for [y (range 0 360 46)]
		(for [x (range 0 640 46)]
		  (let [letter (char counter)]
		    (q/fill 255)
		    (q/text letter, x, y)
		    (inc counter)
		    )
		  ))))
)
#+end_src


#+begin_src clojure :results silent
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(loop [n 20] 
	      (q/line n 40 (+ (* 8 n) 60) 80)
	      (if (> n 40) nil (recur (inc n)))
	      ))
#+end_src

#+begin_src clojure :results silent
  (q/defsketch texty
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) (q/text-align :center, :center))
    :draw #(loop [counter 35]
    (dorun (for [y (range 0 360 46)]
	       (for [x (range 0 640 46)]
		 (let [letter (char counter)]
		   (q/fill 255)
		   (q/text letter, x, y)))))
	     (if (> counter 98) nil (recur (inc counter)))))
#+end_src

#+begin_src clojure :results silent
(q/defsketch simpler-text
:size [640, 360]
:setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))) 
:draw #(q/text (str (char 35)) 100, 40)
)
#+end_src

#+begin_src clojure :results silent :session *cider-repl quilbabel*
(q/defsketch simpler-text
:size [640, 360]
:setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) (q/text (str (char 35)) 100, 40)) 
)
#+end_src

#+begin_src clojure :results silent :session *cider-repl quilbabel*
(q/defsketch simpler-text
:size [640, 360]
:setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) (q/text (str (char (+ 35 (rand-int 94)))) 600, 40))
)
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
  :size [640, 360]
    :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		   (loop [letter 35] (q/text (str (char letter)) 600, 40) (if (> letter 35) nil (recur (inc letter)))))
  )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
  :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(loop [letter 65]
		  (dorun (for [x [580 620]] (q/text (str (char letter)) x, 40)))
		  (if (> letter 36) nil (recur (inc letter)))))
    )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun (for [x [580 620]
			     letter [65 66]]
			 (q/text (str (char letter)) x, 40)))))


#+end_src


#+begin_src clojure :results silent
    (q/defsketch simpler-text
      :size [640, 360]
      :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		  (dorun (for [x [580 620]]
			   (dorun (for [letter [65 66]]
			     (q/text (str (char letter)) x, 40)))))))


#+end_src

#+begin_src clojure :results output
(loop [n [1 2 3] x [10 100 1000]] (println (clojure.string/join [(first x) (first n)])) (if (empty? n) nil (recur (rest n) (rest x))))
#+end_src

#+RESULTS:
: 101
: 1002
: 10003
: 


#+begin_src clojure :results silent
    (q/defsketch simpler-text
      :size [640, 360]
      :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) (loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter)))))
)
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) 
		(dorun 
		 (loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter))))))
    )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) 
			 (loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter)))))
    )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))) 
    :draw #(loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter))))
    )
#+end_src



#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/stroke-weight 8) 
:draw #(q/point 100 40)
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure
;; succeeds!
(q/defsketch dots
:size [480 120]
:setup #(q/stroke-weight 8) 
:draw #(dorun (for [x (range 0 480 20)] (q/point x 40)))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/dots

#+begin_src clojure
  ;; succeeds!
  (q/defsketch rows-of-dots
  :size [480 120]
  :setup #(q/stroke-weight 8) 
  :draw #(dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y)))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots

#+begin_src clojure
  ;; succeeds!
  (q/defsketch rows-of-dots
  :size [480 120]
  :setup #(q/stroke-weight 8) 
  :draw (fn [] (dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y))))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots

#+begin_src clojure
;; works not so good
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw (fn [](dorun
	    (for [x (range 40 480 20)]
	      (dorun
	       (for [y (range 20  120 40)] 
		 (loop [letter (seq (range 65 100))]
		   (q/text (str (char (first letter))) x, y)
		   (if (empty? letter) nil (recur (rest letter))))
			     ))))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots
#+begin_src clojure :results silent
;; pray for helpful iterating distraction
(require '[quil.helpers.seqs :as qs])
(require '[quil.helpers.calc :as qc])

(q/defsketch noise-grid
:size [300 300]
 :setup #(do (q/smooth) (dorun

   (let [x-start (q/random 10)
         y-start (q/random 10)]
     (for [y (qs/range-incl (q/height))
           x (qs/range-incl (q/width))]
       (let [x-noise (qc/mul-add x 0.01 x-start)
             y-noise (qc/mul-add y 0.01 y-start)
             alph    (* 255 (q/noise x-noise y-noise))]
         (q/stroke-int 0 alph)
         (q/line x y (inc x) (inc y))))))))
#+end_src

#+begin_src clojure
  ;; prints all on top of one place??
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup #(do (q/background 0)
		(q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun
		 (for [x (range 40 480 20)
		       y (range 20 120 40)]
		   (loop [letter (seq (range 65 100))]
		     (q/text (str (char (first letter))) x, y)
		     (if (empty? letter) nil (recur (rest letter))))
		   ))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots

#+begin_src clojure :results silent
;; prints but one letter do to not using dorun
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup (fn [] (dorun
		(q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
(map #(q/text (str (char %1)) %2 %3) (range 65 68) [40 200 360 480] [20 50 80 110]))))
#+end_src

#+begin_src clojure :results silent
;; works, given all that it purports to do  

(q/defsketch rows-of-dots
    :size [640 360]
    :setup (fn [] (do (q/background 0)
		(q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
(dorun (map #(q/text (str (char %1)) %2 %3) (range 65 69) [40 200 360 480] [20 50 80 110])))))
#+end_src


#+begin_src clojure :results value scalar
(map #(q/text (str (char %1)) %2)  (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))
(map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))
#+end_src

#+begin_src clojure :results value scalar
(map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))
#+end_src

#+RESULTS:
: ((65 40 20) (66 40 240) (67 40 460) (68 80 20) (69 80 240) (70 80 460) (71 120 20) (72 120 240) (73 120 460))

#+begin_src clojure :results value scalar
(map (fn [coll] (apply + coll)) (map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x))))
#+end_src

#+RESULTS:
: (125 346 567 168 389 610 211 432 653)

#+begin_src clojure :results value scalar
(map (fn [coll] (apply #(q/text (str (char (first coll)) (second coll) (third coll))))) (map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x))))
#+end_src

#+begin_src clojure :results silent
  ;; not really
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup (fn [] (do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		      (dorun (map
			      (fn [coll] (apply #(q/text (str (char (first coll)) (second coll) (nth coll 2)))))
			      (map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))) ))))
#+end_src

#+begin_src clojure :results silent
  ;; hmm
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup (fn [] (do (q/stroke-weight 8)
		      (dorun (map (fn [coll]
				    (apply q/point coll))
				  (for [y [40 80 120] x [20 240 460]] (vector y x)))))))
#+end_src


#+begin_src clojure :results silent
  ;; ohh
  (q/defsketch rows-of-dots
    :size [480 240]
    :setup (fn [] (do (q/stroke-weight 8)
		      (dorun (map (fn [coll]
				    (apply q/point coll))
				  (for [y [40 80 120] x [20 240 460]] (vector x y)))))))
#+end_src



#+begin_src clojure :results silent
  ;; ahh! something
  (q/defsketch rows-of-dots
    :size [480 240]
    :setup (fn [] (do (q/stroke-weight 8)
		      (dorun (map (fn [coll]
				    (apply q/point coll))
				  (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))))))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch rows-of-letterz
    :size [480 240]
    :setup (fn [] (do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		      (dorun (map (fn [coll]
				    (apply #(q/text (str (char %1)) %2 %3) coll)
				    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))))))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch lettur
    :size [480 240]
    :setup (fn [] (do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		      (q/text "A" 80 120))))

#+end_src


#+begin_src clojure :results silent

  (q/defsketch rows-of-letterz
    :size [480 240]
    :setup (fn [] (dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
			 (map (partial #(q/text (str (char (first %))) (second %) (nth % 2)))
			      (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))
			 )))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch a-lettur
    :size [480 240]
    :setup #(dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
			 (map (partial (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))
			      (map (fn add-to [n xs] (cons n xs)) (range 65 75) (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))
			 )))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch no-lettur-with-doruns
    :size [480 240]
    :setup #(dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun

		 (map
		  (partial
		   (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))

		  (dorun
		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 65 75)
		    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))
		(q/background 0)))
#+end_src
** doesn't use the font created with create-font??
#+begin_src clojure :results silent
;;; uhhhh, ok

  (q/defsketch no-lettur-with-doruns
    :size [480 240]
    :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw #(dorun

		 (map
		  (partial
		   (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 65 75)
		    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))
#+end_src

Don't call me plezz
#+begin_src clojure :results silent
;;; uhhhh, very bad to put text-font in draw??

  (q/defsketch no-lettur-with-doruns
    :size [480 240]
    :setup #(do (q/background 0))
    :draw #(dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
    
		 (map
		  (partial
		   (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 65 75)
		    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))
#+end_src
** Basically reproduces original drawing template (missing color changes)!
Uses a ~dorun~ in ~setup~ to create a complicated ~map~-ing scheme with anonymous functions
#+begin_src clojure :results silent
(q/defsketch something
  :size [660 360]
  :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
                 (dorun

		  (map
		   (partial
		    (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 35 127)
		    (for [y (range 40 360 46) x (range 40 640 46)] (vector x y)))))))
#+end_src


Set the background color to black and accurately replicate the "gap" and "margins" of the original
#+begin_src clojure :results silent
(q/defsketch something
  :size [640 360]
  :setup #(do (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
                 (dorun

		  (map
		   (partial
		    (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 35 127)
		    (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y)))))))
#+end_src

Changes fill-stroke, and uses destructuring names, but all is not well

#+begin_src clojure :results silent
  (q/defsketch something
    :size [640 360]

    :setup #(do (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun

		 (map
		  (partial
		   (fn do-it [[letter x y]] 
		     (do 
		       (q/fill 255, 204, 0)
		       (q/text (str (char letter)) x y))))

		  (map
		   (fn add-to [n xs] (cons n xs))
		   (range 35 127)
		   (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y)))))))
#+end_src

Running the text-drawing block from within draw somehow fails to load the font and the ~translate~ values
#+begin_src clojure :results silent
  (q/defsketch wrong-number-of-args-passed-fn
    :size [640 360]
    :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
    :setup #(do (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw 
    (fn [state] 
      (dorun
       (map
	(partial
	 (fn do-it [[letter x y]] 
	   (do
	      (q/fill 255, 204, 0)
	    (q/text (str (char letter)) x y))))


	(map
	 (fn add-to [n xs] (cons n xs))
	 (range 35 127)
	 (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y)))))))
#+end_src

#+begin_src clojure :results output
  (q/defsketch wrong-number-of-args-passed-fn
    :size [640 360]
    :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
    :setup (fn [] (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw

      (fn my-draw [& rest ]
      (dorun
      (map

	(partial
	 (fn do-it [[letter x y]] 
	   (q/text (str (char letter)) x y)))

	(map
	 (fn add-to [n xs] (cons n xs))
	 (range 35 127)
	 (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y))))))
    )
#+end_src

#+RESULTS:

If you include fun-mode, you need to pass state!!??
** using ~doseq~ for side-effects?


#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/stroke-weight 8) 
:draw #(doseq [x (range 40 480 10)] (q/point x 40))
)
#+end_src

#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(do (q/frame-rate 1) (q/stroke-weight 8))
:draw #(do (q/background 255) (doseq [x (range 40 480 10)] (q/point x (q/random 10 110))))
)
#+end_src

#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(do (q/frame-rate 1) (q/stroke-weight 2))
:draw #(do (q/background 230) (doseq [x (range 0 (q/width))] (q/point x (q/random 10 110))))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure :results silent
(q/defsketch diagonals1
:size [480 120]
:setup #(q/ellipse 132, 82, 200, 200))
#+end_src

#+begin_src clojure :results silent
(q/defsketch diagonals1
:size [480 120]
:setup #(q/smooth) 
:draw #(q/ellipse 132, 82, (* (q/random 1) 200), (* (q/random 1) 200)))
#+end_src


#+begin_src clojure
;; wigging out with random colors in the draw!
(q/defsketch diagonals1
:size [480 120]
;; :setup #(q/stroke-weight 1) 
:setup #(q/ellipse-mode (rand-nth [:center]))
:draw #(doseq [x (range 40 480 20)] (q/fill (q/random 255)) (q/ellipse x 40 20 20))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1


#+begin_src clojure
  ;; wigging out with random colors in the draw!
  (q/defsketch diagonals1
  :size [480 120]
  :setup #(q/frame-rate 1) ;; #(q/ellipse-mode (rand-nth [:radius :center :corner]))
  :draw #(dorun (do (for [y (range 0 120 10) x (range 0 480 10)] (doseq [n (range 20)] ;; (q/fill (q/random 255))
								    (q/ellipse x y n n)))))
  )
#+end_src

#+begin_src clojure
  ;; wigging out with random colors in the draw!
  (q/defsketch diagonals1
  :size [480 120]
  :setup #(q/frame-rate 1) ;; #(q/ellipse-mode (rand-nth [:radius :center :corner]))
  :draw #(dorun (do (q/background 255) (q/ellipse 20 20 (q/random 10 20) 10)))
)
#+end_src





#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure :results silent
;; paints all sectors with all characters
(q/defsketch doseqs-pleazz
:size [640 360]
:middleware [quil.middleware/pause-on-error]
:setup (fn my-setup [] (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
:draw #(dorun (for [y (range 0 360 35) x (range 0 640 35)] (doseq [n (range 35 110)] (q/text (str (char n)) x y))))
)
#+end_src


#+begin_src clojure
;; wigging out with random colors and (random-ellipse mode transformations) in the draw!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/ellipse-mode (rand-nth [:radius :center :corner]))
:draw #(doseq [n (range 10) y (range 0 120 20 ) x (range 0 480 20)] (q/fill (q/random 255)) (q/ellipse x y n n))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure
;; slower wigging out with random colors in the draw!
(q/defsketch diagonals1
:size [480 120]
:setup #(do (q/smooth) (q/ellipse-mode (rand-nth [:radius :center :corner])) (q/frame-rate 10))
:draw #(doseq [n (range 10) y (range 0 120 20 ) x (range 0 480 20)] (q/fill (q/random 255)) (q/ellipse x y n n))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

** whoa, randomness
#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [state] (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120))))
      ))
#+end_src

#+begin_src clojure :results output
;; will fail if you remove "state" argument but still include fun-mode middleware
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [] (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120))))
      ))
#+end_src

#+RESULTS:

#+begin_src clojure :results silent
;; basically succeeds if you remove fun-mode middleware
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [] (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120))))
      ))
#+end_src

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [state] (do (q/fill (q/random 255)) (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120)))))
      ))
#+end_src

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/background 0)))
      :draw (fn my-draw [state] (do (apply q/translate (repeatedly 2 #(q/random 20 320))) (q/fill (q/random 255)) (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 40)))))
      ))
#+end_src

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/background 0)))
      :draw (fn my-draw [state] (do (q/translate (q/random 20 600) (q/random 20 320)) (q/fill (q/random 255)) (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 40)))))
      ))
#+end_src

#+RESULTS:
** trying out pause-on-error with rows-of-dots
#+begin_src clojure
  ;; succeeds! (IN SPITE OF ITSELF!) (must have fun-mode turned-off)
  (q/defsketch rows-of-dots
  :size [640 640]
  :middleware [quil.middleware/pause-on-error]
  :setup #(q/stroke-weight 8) 
  :draw (fn [] (dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y))))))
  )
#+end_src

#+begin_src clojure
  ;; succeeds! (IN SPITE OF ITSELF!)
  (q/defsketch rows-of-dots
  :size [640 640]
  :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
  :setup #(q/stroke-weight 8) 
  :draw (fn [state] (dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y))))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots

: #'quilbabel.dynamic/rows-of-dots

Why does the above change the namespace when called as a babel-block
#+begin_src clojure :results value
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]


#+begin_src clojure :results value
(in-ns 'quilbabel.core)
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.core]#namespace[quilbabel.core]

#+begin_src clojure :results silent
(defn blank [] ())
#+end_src
* using fun-mode
** test out update functions
#+begin_src clojure
;; use update with inc to get bigger
    (q/defsketch diagonals1
    :size [480 120]
    :setup #(do (q/frame-rate 1) {:x 0 :y 0 :r 1})
    :draw (fn my-draw [state] (q/background 255) (q/ellipse 20 20 (:r state) (:r state)))
    :update (fn my-update [state] (update-in state [:r] inc))
    :middleware [m/fun-mode m/pause-on-error]
  )
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals1

#+begin_src clojure
  ;; use update with inc to get bigger
  (q/defsketch diagonals1
    :size [480 120]
    :setup #(do (q/ellipse-mode :corner) (q/frame-rate 30) {:x 0 :y 0 :r 1})
    :draw (fn my-draw [state]
	    (q/background 255)
	    (q/ellipse (q/map-range (q/sin (:r state)) -1 1 0 (- (q/width) 30)), 
		       (q/map-range (q/sin (:r state)) -1 1 0 (- (q/height) 30)), 30, 30))
    :update (fn my-update [state] (update-in state [:r] #(+ 0.1 %)))
    :middleware [m/fun-mode m/pause-on-error]
    )
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals1
