* various administrative notes and experiments
   :PROPERTIES:
   :VISIBILITY: folded
   :END:
** hide testing misc. clojure blocks
#+begin_src clojure :results silent :show-process t
*ns*
#+end_src

#+begin_src clojure :results silent
(for [n (range 5)] (rand-int 8))
#+end_src

#+begin_src clojure
(for [n (range 5)] (rand-int 8))
#+end_src

#+RESULTS:
| 6 | 7 | 5 | 6 | 4 |



#+begin_src clojure :results output
(loop [n [1 2 3] x [10 100 1000]] (println (clojure.string/join [(first x) (first n)])) (if (empty? n) nil (recur (rest n) (rest x))))
#+end_src


#+begin_src clojure
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]



#+begin_src clojure :results output
(clojure.repl/dir quilbabel.dynamic)
#+end_src

#+RESULTS:
: diagonals3
: draw
: setup
** your loaded libs
Pretty-print! (an impressively long and vaguely helpful list)
#+begin_src clojure :results value pp
(loaded-libs)
#+end_src

#+RESULTS:
#+begin_example
#{cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.complete
  cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.info
  cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.util.analysis
  cider.inlined-deps.cljs-tooling.v0v2v0.cljs-tooling.util.misc
  cider.inlined-deps.compliment.v0v3v4.compliment.context
  cider.inlined-deps.compliment.v0v3v4.compliment.core
  cider.inlined-deps.compliment.v0v3v4.compliment.sources
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.class-members
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.keywords
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.local-bindings
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.namespaces-and-classes
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.ns-mappings
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.resources
  cider.inlined-deps.compliment.v0v3v4.compliment.sources.special-forms
  cider.inlined-deps.compliment.v0v3v4.compliment.utils
  cider.inlined-deps.javaclasspath.v0v2v3.clojure.java.classpath
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.dependency
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.file
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.find
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.parse
  cider.inlined-deps.toolsnamespace.v0v3v0-alpha3.clojure.tools.namespace.track
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.default-data-readers
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.impl.commons
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.impl.utils
  cider.inlined-deps.toolsreader.v1v0v0.clojure.tools.reader.reader-types
  cider.nrepl cider.nrepl.middleware.complete
  cider.nrepl.middleware.debug cider.nrepl.middleware.info
  cider.nrepl.middleware.inspect cider.nrepl.middleware.ns
  cider.nrepl.middleware.out cider.nrepl.middleware.pprint
  cider.nrepl.middleware.stacktrace cider.nrepl.middleware.track-state
  cider.nrepl.middleware.util.cljs
  cider.nrepl.middleware.util.error-handling
  cider.nrepl.middleware.util.inspect
  cider.nrepl.middleware.util.instrument
  cider.nrepl.middleware.util.java
  cider.nrepl.middleware.util.java.parser
  cider.nrepl.middleware.util.meta cider.nrepl.middleware.util.misc
  cider.nrepl.middleware.util.namespace
  cider.nrepl.middleware.util.spec cider.nrepl.print-method
  cider.nrepl.version clj-native.callbacks clj-native.direct
  clj-native.direct-util clj-native.functions clj-native.structs
  clj-native.unions clojure.core.protocols clojure.core.server
  clojure.data.json clojure.edn clojure.instant clojure.java.browse
  clojure.java.io clojure.java.javadoc clojure.java.shell clojure.main
  clojure.pprint clojure.reflect clojure.repl clojure.set
  clojure.stacktrace clojure.string clojure.template clojure.test
  clojure.tools.nrepl clojure.tools.nrepl.ack
  clojure.tools.nrepl.bencode clojure.tools.nrepl.middleware
  clojure.tools.nrepl.middleware.interruptible-eval
  clojure.tools.nrepl.middleware.load-file
  clojure.tools.nrepl.middleware.pr-values
  clojure.tools.nrepl.middleware.session clojure.tools.nrepl.misc
  clojure.tools.nrepl.server clojure.tools.nrepl.transport clojure.uuid
  clojure.walk clojure.zip complete.core dynapath.defaults
  dynapath.dynamic-classpath dynapath.util org.satta.glob
  overtone.algo.chance overtone.algo.fn overtone.algo.lists
  overtone.algo.scaling overtone.algo.trig overtone.api overtone.at-at
  overtone.byte-spec overtone.config.file-store overtone.config.log
  overtone.config.store overtone.helpers.audio-file
  overtone.helpers.doc overtone.helpers.file overtone.helpers.hash
  overtone.helpers.lib overtone.helpers.map overtone.helpers.math
  overtone.helpers.ns overtone.helpers.old-contrib overtone.helpers.ref
  overtone.helpers.seq overtone.helpers.stereo overtone.helpers.string
  overtone.helpers.synth overtone.helpers.system overtone.helpers.zip
  overtone.jna-path overtone.libs.app-icon overtone.libs.asset
  overtone.libs.asset.store overtone.libs.boot-msg
  overtone.libs.counters overtone.libs.deps overtone.libs.event
  overtone.libs.handlers overtone.live overtone.midi
  overtone.music.pitch overtone.music.rhythm overtone.music.time
  overtone.music.tuning overtone.nativescsynth.availability
  overtone.osc overtone.osc.decode overtone.osc.dyn-vars
  overtone.osc.encode overtone.osc.pattern overtone.osc.peer
  overtone.osc.util overtone.repl.debug overtone.repl.examples
  overtone.repl.graphviz overtone.repl.inst overtone.repl.shell
  overtone.repl.ugens overtone.samples.freesound
  overtone.samples.freesound.search-results
  overtone.samples.freesound.url overtone.sc.bindings
  overtone.sc.buffer overtone.sc.bus overtone.sc.cgens.audio-in
  overtone.sc.cgens.beq-suite overtone.sc.cgens.berlach
  overtone.sc.cgens.bhob overtone.sc.cgens.buf-io
  overtone.sc.cgens.demand overtone.sc.cgens.dyn overtone.sc.cgens.env
  overtone.sc.cgens.freq overtone.sc.cgens.fx overtone.sc.cgens.info
  overtone.sc.cgens.io overtone.sc.cgens.line overtone.sc.cgens.mix
  overtone.sc.cgens.oscillators overtone.sc.cgens.tap overtone.sc.clock
  overtone.sc.defaults overtone.sc.defcgen overtone.sc.dyn-vars
  overtone.sc.envelope overtone.sc.example
  overtone.sc.examples.audio-in overtone.sc.examples.blackrain
  overtone.sc.examples.compander overtone.sc.examples.demand
  overtone.sc.examples.dyn overtone.sc.examples.membrane
  overtone.sc.examples.osc overtone.sc.examples.trig
  overtone.sc.examples.vosim overtone.sc.foundation-groups
  overtone.sc.info overtone.sc.machinery.allocator
  overtone.sc.machinery.defexample overtone.sc.machinery.server.args
  overtone.sc.machinery.server.comms
  overtone.sc.machinery.server.connection
  overtone.sc.machinery.server.native
  overtone.sc.machinery.server.osc-validator
  overtone.sc.machinery.synthdef overtone.sc.machinery.ugen.categories
  overtone.sc.machinery.ugen.check overtone.sc.machinery.ugen.common
  overtone.sc.machinery.ugen.defaults overtone.sc.machinery.ugen.doc
  overtone.sc.machinery.ugen.fn-gen
  overtone.sc.machinery.ugen.intern-ns
  overtone.sc.machinery.ugen.metadata.basicops
  overtone.sc.machinery.ugen.metadata.beq-suite
  overtone.sc.machinery.ugen.metadata.binaryopugen
  overtone.sc.machinery.ugen.metadata.buf-io
  overtone.sc.machinery.ugen.metadata.chaos
  overtone.sc.machinery.ugen.metadata.compander
  overtone.sc.machinery.ugen.metadata.control
  overtone.sc.machinery.ugen.metadata.delay
  overtone.sc.machinery.ugen.metadata.demand
  overtone.sc.machinery.ugen.metadata.envgen
  overtone.sc.machinery.ugen.metadata.extras.ay
  overtone.sc.machinery.ugen.metadata.extras.bat
  overtone.sc.machinery.ugen.metadata.extras.bbcut2u
  overtone.sc.machinery.ugen.metadata.extras.berlach
  overtone.sc.machinery.ugen.metadata.extras.bhob
  overtone.sc.machinery.ugen.metadata.extras.blackrain
  overtone.sc.machinery.ugen.metadata.extras.distortion
  overtone.sc.machinery.ugen.metadata.extras.glitch
  overtone.sc.machinery.ugen.metadata.extras.mda
  overtone.sc.machinery.ugen.metadata.extras.membrane
  overtone.sc.machinery.ugen.metadata.extras.sl
  overtone.sc.machinery.ugen.metadata.extras.stk
  overtone.sc.machinery.ugen.metadata.extras.tju
  overtone.sc.machinery.ugen.metadata.extras.vbap
  overtone.sc.machinery.ugen.metadata.extras.vosim
  overtone.sc.machinery.ugen.metadata.ff-osc
  overtone.sc.machinery.ugen.metadata.fft
  overtone.sc.machinery.ugen.metadata.fft-unpacking
  overtone.sc.machinery.ugen.metadata.fft2
  overtone.sc.machinery.ugen.metadata.filter
  overtone.sc.machinery.ugen.metadata.grain
  overtone.sc.machinery.ugen.metadata.info
  overtone.sc.machinery.ugen.metadata.input
  overtone.sc.machinery.ugen.metadata.io
  overtone.sc.machinery.ugen.metadata.line
  overtone.sc.machinery.ugen.metadata.machine-listening
  overtone.sc.machinery.ugen.metadata.misc
  overtone.sc.machinery.ugen.metadata.noise
  overtone.sc.machinery.ugen.metadata.osc
  overtone.sc.machinery.ugen.metadata.pan
  overtone.sc.machinery.ugen.metadata.random
  overtone.sc.machinery.ugen.metadata.trig
  overtone.sc.machinery.ugen.metadata.unaryopugen
  overtone.sc.machinery.ugen.sc-ugen
  overtone.sc.machinery.ugen.special-ops
  overtone.sc.machinery.ugen.specs overtone.sc.node
  overtone.sc.protocols overtone.sc.sample overtone.sc.server
  overtone.sc.synth overtone.sc.trig overtone.sc.ugens overtone.sc.util
  overtone.sc.vbap overtone.speech overtone.studio.core
  overtone.studio.fx overtone.studio.inst overtone.studio.midi
  overtone.studio.midi-player overtone.studio.mixer
  overtone.studio.scope overtone.studio.util overtone.studio.wavetable
  overtone.version quil.applet quil.core quil.helpers.applet-listener
  quil.helpers.docs quil.middleware quil.middlewares.bind-output
  quil.middlewares.deprecated-options quil.middlewares.fun-mode
  quil.middlewares.navigation-2d quil.middlewares.navigation-3d
  quil.middlewares.pause-on-error quil.middlewares.safe-fns quil.sketch
  quil.util quilbabel.core quilbabel.dynamic}
#+end_example

** Processing translation
README of processing-examples
[[file:~/org/secondary/processing-examples/README.org::*babel%20sandbox][babel sandbox]]
** current namespaces
Why does the namespace sometimes change when calling babel-blocks?
#+begin_src clojure :results value
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]


#+begin_src clojure :results value
(in-ns 'quilbabel.core)
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.core]#namespace[quilbabel.core]

#+begin_src clojure :results silent
(defn blank [] ())
#+end_src
** noise-grid for iterative distraction
#+begin_src clojure :results silent
;; pray for helpful iterating distraction
(require '[quil.helpers.seqs :as qs])
(require '[quil.helpers.calc :as qc])

(q/defsketch noise-grid
:size [300 300]
 :setup #(do (q/smooth) (dorun

   (let [x-start (q/random 10)
         y-start (q/random 10)]
     (for [y (qs/range-incl (q/height))
           x (qs/range-incl (q/width))]
       (let [x-noise (qc/mul-add x 0.01 x-start)
             y-noise (qc/mul-add y 0.01 y-start)
             alph    (* 255 (q/noise x-noise y-noise))]
         (q/stroke-int 0 alph)
         (q/line x y (inc x) (inc y))))))))
#+end_src
* initial experiments based on wiki examples
Oh, do ~:reload~ my friends
** first passes
*** deal with namespaces
  :PROPERTIES:
  :ID:       BD6805C4-0991-4002-98FD-E0AF86528FA2
  :END:
#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.core)
#+end_src

#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.dynamic)
#+end_src

#+begin_src clojure :show-process t
(in-ns 'quilbabel.dynamic)
#+end_src
*** versions of draw
**** Version currently in core:

Colored "rim" and greyscaled "center"

#+begin_src clojure :show-process t
(defn draw []
  (q/stroke (q/random 255) (q/random 255) (q/random 255))
  (q/fill (q/random 255))
  (let [diam (q/random 100)
        x    (q/random (q/width))
        y    (q/random (q/height))]
    (q/ellipse x y diam diam)))
#+end_src

#+begin_src clojure :show-process t
(in-ns 'quilbabel.dynamic)
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

Without changing namespace in the REPL!!
: #namespace[quilbabel.core]


Must eval the namespace change in the REPL?
**** Black and white version with "proper" ellipses
#+begin_src clojure :show-process t
  (defn draw []
    (q/stroke (q/random 255))
    (q/stroke-weight (q/random 10))
    (q/fill (q/random 255))
    (let [diam (q/random 100)
	  x    (q/random (q/width))
	  y    (q/random (q/height))]
      (q/ellipse x y (* 2 diam) diam)))
#+end_src

#+RESULTS:
: #'quilbabel.core/draw


Now, you need not even reload!! Just eval the block
**** Color version:
#+begin_src clojure :show-process t
  (defn draw []
    (q/stroke (q/random 255) (q/random 255) (q/random 255))
    (q/stroke-weight (q/random 10))
    (q/fill (q/random 255))

    (let [diam (q/random 100)
	  x (q/random (q/width))
	  y (q/random (q/height))]
      (q/ellipse x y diam diam)))

#+end_src

#+RESULTS:
: #'quilbabel.dynamic/draw

** quil-sketches.mouse
*** original as one block (~quil-sketches.mouse~ namespace)
#+begin_src clojure :show-process t
(ns quil-sketches.mouse
  (:require [quil.core :refer :all]))

(defn setup []
  (smooth)
  (no-stroke)
  (set-state! :mouse-position (atom [0 0])))

(defn draw
  []
  (background-float 125)
  (stroke-weight 20)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))

(defn mouse-moved []
  (let [x (mouse-x)  y (mouse-y)]
    (reset! (state :mouse-position) [x y])))

(defsketch mouse-example
  :title "Mouse example."
  :size [200 200]
  :setup setup
  :draw draw
  :mouse-moved mouse-moved)

(defn -main [& args])
#+end_src

*** use tangling to dynamically add code to project?
Here is the code copied straight from the quil-examples into a babel block

Note that I use a tangle argument to create this file in the src directory of this project

This is just to make sure I can get the basic thing working before moving on to a dynamic workflow.
#+begin_src clojure :show-process t :tangle "src/quilbabel/mousebabel.clj"
(ns quilbabel.mousebabel
  (:require [quil.core :refer :all]))

(defn setup []
  (smooth)
  (no-stroke)
  (set-state! :mouse-position (atom [0 0])))

(defn draw
  []
  (background-float 125)
  (stroke-weight 20)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))

(defn mouse-moved []
  (let [x (mouse-x)  y (mouse-y)]
    (reset! (state :mouse-position) [x y])))

(defsketch mouse-example
  :title "Mouse example."
  :size [200 200]
  :setup setup
  :draw draw
  :mouse-moved mouse-moved)

;; (defn -main [& args])

#+end_src

Will reload sketch the whole, original version of the sketch
#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.mousebabel)
#+end_src
*** break up namespace
Now get ready to tangle two files, one for the core defsketch and one for the setup and draw, so that you can use the latter to dynamically reload the changes from babel
**** core
#+begin_src clojure :show-process t :tangle "src/quilbabel/mousebabelcore.clj"
(ns quilbabel.mousebabel
(:require [quil.core :refer :all])
(:require [quilbabel.mousebabeldynamic :as dynamic]))

(defsketch mouse-example
  :title "Mouse example."
  :size [200 200]
  :setup dynamic/setup
  :draw dynamic/draw
  :mouse-moved dynamic/mouse-moved)

#+end_src
**** dynamic
#+begin_src clojure :show-process t :tangle "src/quilbabel/mousebabeldynamic.clj"
(ns quilbabel.mousebabeldynamic
  (:require [quil.core :refer :all]))

(defn setup []
  (smooth)
  (no-stroke)
  (set-state! :mouse-position (atom [0 0])))

(defn draw
  []
  (background-float 125)
  (stroke-weight 20)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))

(defn mouse-moved []
  (let [x (mouse-x)  y (mouse-y)]
    (reset! (state :mouse-position) [x y])))
#+end_src
**** reload
#+begin_src clojure :show-process t
(use :reload 'quilbabel.mousebabelcore)
#+end_src

#+RESULTS:
: nil
**** Use the ~in-ns~ command in the REPL
#+BEGIN_SRC clojure :show-process t

(in-ns 'quilbabel.mousebabeldynamic)
#+END_SRC

Check that the change took hold here in babel-land.
#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.mousebabeldynamic]
**** Change the draw function 
#+begin_src clojure :show-process t
(defn draw
  []
  (background-float 125)
  (stroke-weight 2)
  (stroke-float 10)
  (let [[x y] @(state :mouse-position)]
    (point x y)))
#+end_src

#+RESULTS:
: #'quilbabel.mousebabeldynamic/draw

** functional mode using babel
*** original as one block

Use the repl to call "use" the "namespace/file" you create here:

(DON'T FORGET TO CHANGE THE NAMESPACE TO MATCH THE FILE!
#+begin_src clojure :show-process t :tangle "src/quilbabel/funbabel.clj"
(ns quilbabel.funbabel
  (:require [quil.core :as q]
            [quil.middleware :as m]))

(def min-r 10)

(defn setup []
  ; initial state
  {:x 0 :y 0 :r min-r
   }
  )

(defn my-update [state]
  ; increase radius of the circle by 1 on each frame
  (update-in state [:r] inc))

(defn draw [state]
  (q/background 255)
  (q/ellipse (:x state) (:y state) (:r state) (:r state)))

; decrease radius by 1 but keeping it not less than min-r
(defn shrink [r]
  (max min-r (dec r)))

(defn mouse-moved [state event]
  (-> state
      ; set circle position to mouse position
      (assoc :x (:x event) :y (:y event))
      ; decrease radius
      (update-in [:r] shrink)))

(q/defsketch fun-mode-example
  :size [200 200]
  :setup setup
  :draw draw
  :update my-update
  :mouse-moved mouse-moved
  :middleware [m/fun-mode])

#+end_src

Can I dynamically
#+begin_src clojure :show-process t :results silent
(def min-r 30)
#+end_src

#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

#+begin_src clojure :show-process t
(use :reload 'quilbabel.funbabel)
#+end_src

#+RESULTS:
: nil
** changing frame rates dynamically?
*** use "reload" option
Will run the sketch ~quil-example~ in quilbabel/src/quilbabel/core.clj
#+begin_src clojure :results silent :show-process t
(use :reload 'quilbabel.core)
#+end_src

Now, copy this to the REPL in order to get define functions that use the "dynamic" namespace
#+begin_src clojure :show-process t
(in-ns 'quilbabel.dynamic)
#+end_src

But, no matter how much you want to change the frame-rate from setup, it appears that this is already done
#+begin_src clojure :show-process t
(defn setup []
  (q/frame-rate 10))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/setup
* use anonymous functions in defsketch
  :PROPERTIES:
  :ID:       828D0FC4-0291-4FE4-B457-CF3DD7864E27
  :END:
** concentrate circles in the top corner
#+begin_src clojure :show-process t :results silent
  (q/defsketch ellipses-with-fn-literals1
    :setup #(q/frame-rate 10)
    :draw #(q/ellipse (q/random 100) (q/random 100) 10 10)
	       )
#+end_src

#+RESULTS:
: #'my-simple-enlive.core/ellipses-with-fn-literals1
** use a ~do~ block to run two different drawings concurrent
#+begin_src clojure :show-process t
  (q/defsketch ellipses-with-fn-literals2
    :setup #(q/frame-rate 30)
    :draw #(do (q/ellipse (q/random 100) (q/random 100) 10 10)
	       ;; (Thread/sleep 3000)
	       (q/ellipse (q/random 100 300) (q/random 100 300) 10 10)
  ))

#+end_src

#+RESULTS:
: #'quilbabel.dynamic/allthree
** draw single pixel circles next to 10 pixel circles
#+begin_src clojure :show-process t
  (q/defsketch ellipses-with-fn-literals3
    :setup #(q/frame-rate 30)
    :draw #(do (q/ellipse (q/random 100) (q/random 100) (q/random 1 3) (q/random 1 3))
	       ;; (Thread/sleep 3000)
	       (q/ellipse (q/random 100 300) (q/random 100 300) 10 10)
  ))

#+end_src

#+RESULTS:
: #'quilbabel.dynamic/allthree
** nest anonymous functions, but not function literals (esp. without arguments!)
#+begin_src clojure :show-process t
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.core]

#+begin_src clojure :show-process t
(q/defsketch drawcircles-with-fun-mode
:size[480 120]
:setup (fn [] {:x 0, :y 0, :r 10})
:draw #(q/ellipse (:x %) (:y %) (:r %) (:r %))
:update #(update-in % [:r] inc)
:mouse-moved (fn [m e] (-> m (assoc :x (:x e) :y (:y e)) (update-in [:r] #(max 10 (dec %)))))
:middleware [m/fun-mode])
#+end_src

#+RESULTS:
: #'quilbabel.core/drawcircles-with-fun-mode

FAILS
#+begin_src clojure :show-process t
;; fails because no "draw"?
(q/defsketch diagonals
:size [480 120]
:setup (fn [] (do (q/stroke-weight 8) (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals

#+begin_src clojure :show-process t
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/stroke-weight 8)
:draw #(q/line 10 40 (+ 10 60) 80)
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals1

** use dorun
FAILS
#+begin_src clojure :show-process t
;; fails because lazy-seq ~for~
(q/defsketch diagonals
:size [480 120]
:setup #(q/stroke-weight 8)
:draw #(for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals

#+begin_src clojure :show-process t
;; succeeds with DORUN
(q/defsketch diagonals2
:size [480 120]
:setup #(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80)))
)
#+end_src
#+RESULTS:
: #'quilbabel.core/diagonals2

#+begin_src clojure :show-process t
;; succeeds with DORUN
(q/defsketch diagonals3
:size [480 120]
:setup #(do (q/stroke-weight 8) (dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
)
#+end_src

** use setup with ~random~ values
#+RESULTS:
: #'quilbabel.core/diagonals3
#+begin_src clojure :show-process t :results silent
;; stroke-weight set just once
(q/defsketch diagonals3
:size [480 120]
:setup #(do (q/stroke-weight (rand-int 8)) (dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
)
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals3

#+begin_src clojure
;; captures same stroke-weight 
(q/defsketch diagonals3
:size [480 120]
:draw #(dorun (for [n (range 20 400 60)] (do (q/stroke-weight (rand-int 34)) (q/line n 40 (+ n 60) 80))))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

#+begin_src clojure
;; use overtone function
;; when used with ~:draw~ runs through all rand n?
  (q/defsketch diagonals3
    :size [480 120]
    :draw #(let [x (overtone.algo.chance/weighted-choose [1 20 40 90] [0.5 0.3 0.125 0.075])]
	    (do (q/stroke-weight (rand-int x))
		(q/line 10 40 (+ 10 50) 80))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3


#+begin_src clojure
;; when used with ~:setup~ get different behavior
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(let [x (overtone.algo.chance/weighted-choose [10 20 40 90] [0.5 0.3 0.125 0.075])]
	    (do (q/stroke-weight (rand-int x))
		(q/line 10 40 (+ 10 50) 80))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

** use ~dorun~ in a setup function
#+begin_src clojure
;; use setup with dorun
(q/defsketch diagonals3
:size [480 120]
:setup #(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

#+begin_src clojure
;; proper use of ~for~ loop with ~do~ block?!
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(dorun (for [n (range 20 400 60)]
		     (do (let [x (overtone.algo.chance/weighted-choose [10 20 40 90] [0.5 0.3 0.125 0.075])]
			   (q/stroke-weight (rand-int x))
			   (q/line n 40 (+ n 60) 80))))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

** primitive ~overtone~ call in a quil ~sketch~
#+begin_src clojure
((overtone.live/synth (overtone.live/out 0 (overtone.live/sin-osc))))
#+end_src

#+RESULTS:
: #<synth-node[loading]: quilbabel.dynamic/anon-3 39>

#+begin_src clojure
(overtone.live/kill 39)
#+end_src

#+RESULTS:
: nil

#+begin_src clojure
  ;; proper use of ~for~ loop with ~do~ block?!
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(dorun (for [n (range 20 400 60)]
		     (do (let [x (overtone.algo.chance/weighted-choose [10 20 40 90] [0.5 0.3 0.125 0.075])]
			   (q/stroke-weight (rand-int x))
			   ((overtone.live/synth (overtone.live/out 0 (overtone.live/sin-osc (+ (rand-nth [100 300 500]) (* 10 (rand) ))))))
			   (q/line n 40 (+ n 60) 80))))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3

** save a frame?
Without an argument...

/Users/ao/scratch/quilbabel/screen-0000.tif

#+begin_src clojure :results silent
  ;; writes to wherever notion of "current directory" is
    (q/defsketch diagonals3
      :size [480 120]
      :setup #(do (q/stroke-weight (rand-int 8))
		  (dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80)))
		  ;; (q/save-frame)
      ))
#+end_src


#+begin_src clojure
  ;; stroke-weight set just once
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(do (q/stroke-weight (rand-int 8))
		(dorun (for [n (range 20 400 60)] (q/line n 40 (+ n 60) 80)))
		(q/save-frame "./resources/lines1.jpg")
    ))
#+end_src

#+RESULTS:
: #'quilbabel.core/diagonals3

#+begin_src clojure :results output
(clojure.repl/doc q/save-frame)
#+end_src

#+RESULTS:
#+begin_example
-------------------------
quil.core/save-frame
([] [name])
  Saves an image identical to the current display window as a
  file. May be called multple times - each file saved will have a
  unique name. Name and image formate may be modified by passing a
  string parameter of the form "foo-####.ext" where foo- can be any
  arbitrary string, #### will be replaced with the current frame id
  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg

  Examples:
  (save-frame)
  (save-frame "pretty-pic-####.jpg")
#+end_example

** translating arbitrary GSWP code
#+begin_src processing
size(480, 120);
noStroke();
background(204, 226, 225);    // Light blue color
fill(255, 0, 0, 160);         // Red color
ellipse(132, 82, 200, 200);   // Red circle
fill(0, 255, 0, 160);         // Green color
ellipse(228, -16, 200, 200);  // Green circle
fill(0, 0, 255, 160);         // Blue color
ellipse(268, 118, 200, 200);  // Blue circle

#+end_src

#+begin_src clojure :results silent
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(do (q/no-stroke)
(q/background 204, 226, 225)
(q/fill 255, 0, 0, 160)
(q/ellipse 132, 82, 200, 200)
(q/fill 0, 255, 0, 160)
(q/ellipse 228, -16, 200, 200)
(q/fill 0, 0, 255, 160)
(q/ellipse 268, 118, 200, 200)
;; save-frame?
;; (q/save-frame "./resources/colors1.jpg")
    ))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals3
* text and typography practice
** simplest
#+begin_src clojure :results silent
(q/defsketch texty
:size [480, 120]
:setup #(q/text-font (q/create-font "data/Trattatello.ttf" 24))
:draw #(do (q/text-size 48) (q/text "YO Adrian" 100, 50))
  )
#+end_src
** use Letter.pde model from Processing Basics
*** failed attempts
#+begin_src clojure :results silent
  (q/defsketch texty
    :size [640, 360]

    :setup #(do (q/background 0)
		(q/text-font
		 (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(q/text-align :center, :center))
    :draw #(dorun 
	    (let [counter 35]
	      (for [y (range 0 360 46)]
		(for [x (range 0 640 46)]
		  (let [letter (char counter)]
		    (q/fill 255)
		    (q/text letter, x, y)
		    (inc counter)
		    )
		  ))))
)
#+end_src

#+begin_src clojure :results silent
  (q/defsketch texty
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) (q/text-align :center, :center))
    :draw #(loop [counter 35]
    (dorun (for [y (range 0 360 46)]
	       (for [x (range 0 640 46)]
		 (let [letter (char counter)]
		   (q/fill 255)
		   (q/text letter, x, y)))))
	     (if (> counter 98) nil (recur (inc counter)))))
#+end_src
*** use loop and recur to draw diagonals
#+begin_src clojure :results silent
  (q/defsketch diagonals3
    :size [480 120]
    :setup #(loop [n 20] 
	      (q/line n 40 (+ (* 8 n) 60) 80)
	      (if (> n 40) nil (recur (inc n)))
	      ))
#+end_src
*** draw a single character
Putting the q/text call in draw doesn't use the font-created??
#+begin_src clojure :results silent
(q/defsketch simpler-text
:size [640, 360]
:setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))) 
:draw #(q/text (str (char 35)) 100, 40)
)
#+end_src

Why is using setup for all drawing is better?
#+begin_src clojure :results silent :session *cider-repl quilbabel*
(q/defsketch simpler-text
:size [640, 360]
:setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) (q/text (str (char 35)) 100, 40)) 
)
#+end_src

Draw a random-character
#+begin_src clojure :results silent :session *cider-repl quilbabel*
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) 
		(q/text (str (char (+ 35 (rand-int 94)))) 600, 40))
    )
#+end_src

*** Two characters 
on top of one another with loop
#+begin_src clojure :results silent
  (q/defsketch simpler-text
  :size [640, 360]
    :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		   (loop [letter 35] (q/text (str (char letter)) 600, 40) (if (> letter 35) nil (recur (inc letter)))))
  )
#+end_src

Spread out
#+begin_src clojure :results silent
  (q/defsketch simpler-text
  :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(loop [letter 65]
		  (dorun (for [x [580 620]] (q/text (str (char letter)) x, 40)))
		  (if (> letter 36) nil (recur (inc letter)))))
    )
#+end_src

Multiple characters on top of one another in multiple locations 
#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun (for [x [580 620]
			     letter [65 66]]
			 (q/text (str (char letter)) x, 40)))))


#+end_src

No difference
#+begin_src clojure :results silent
    (q/defsketch simpler-text
      :size [640, 360]
      :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		  (dorun (for [x [580 620]]
			   (dorun (for [letter [65 66]]
			     (q/text (str (char letter)) x, 40)))))))


#+end_src



#+RESULTS:
: 101
: 1002
: 10003
: 


*** Two different characters (Complains because...)
#+begin_src clojure :results silent
      (q/defsketch simpler-text
	:size [640, 360]
	:setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		    (loop [x [580 600] letter [65 66]]
		      (q/text (str (char (first letter))) (first x), 40)
		      (if (empty? x) nil (recur (rest x) (rest letter)))))
  )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) 
		(dorun 
		 (loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter))))))
    )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)) 
			 (loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter)))))
    )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch simpler-text
    :size [640, 360]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))) 
    :draw #(loop [x [580 600] letter [65 66]] (q/text (str (char (first letter))) (first x), 40) (if (empty? x) nil (recur (rest x) (rest letter))))
    )
#+end_src


*** dot and dots
**** Single dot
#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/stroke-weight 8) 
:draw #(q/point 100 40)
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1
**** Line of dots
#+begin_src clojure
;; succeeds!
(q/defsketch dots
:size [480 120]
:setup #(q/stroke-weight 8) 
:draw #(dorun (for [x (range 0 480 20)] (q/point x 40)))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/dots
**** 2D lines of dots
#+begin_src clojure
  ;; succeeds!
  (q/defsketch rows-of-dots
  :size [480 120]
  :setup #(q/stroke-weight 8) 
  :draw #(dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y)))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots

#+begin_src clojure
  ;; succeeds!
  (q/defsketch rows-of-dots
  :size [480 120]
  :setup #(q/stroke-weight 8) 
  :draw (fn [] (dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y))))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots
**** please rows of letters (no.)
#+begin_src clojure
;; works not so good
  (q/defsketch rows-of-letters
    :size [480 120]
    :setup #(do (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw (fn [](dorun
	    (for [x (range 40 480 20)]
	      (dorun
	       (for [y (range 20  120 40)] 
		 (loop [letter (seq (range 65 100))]
		   (q/text (str (char (first letter))) x, y)
		   (if (empty? letter) nil (recur (rest letter))))
			     ))))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots


#+begin_src clojure
  ;; prints all on top of one place??
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup #(do (q/background 0)
		(q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun
		 (for [x (range 40 480 20)
		       y (range 20 120 40)]
		   (loop [letter (seq (range 65 100))]
		     (q/text (str (char (first letter))) x, y)
		     (if (empty? letter) nil (recur (rest letter))))
		   ))))
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots
**** will print letters (and complain)
#+begin_src clojure :results silent
;; prints but one letter do to not using dorun
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup (fn [] (dorun
		(q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
(map #(q/text (str (char %1)) %2 %3) (range 65 68) [40 200 360 480] [20 50 80 110]))))
#+end_src

#+begin_src clojure :results silent
;; works, given all that it purports to do  

(q/defsketch rows-of-dots
    :size [640 360]
    :setup (fn [] (do (q/background 0)
		(q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
(dorun (map #(q/text (str (char %1)) %2 %3) (range 65 69) [40 200 360 480] [20 50 80 110])))))
#+end_src
**** testing out map
#+begin_src clojure :results value scalar
(map #(q/text (str (char %1)) %2)  (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))
(map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))
#+end_src

#+begin_src clojure :results value scalar
(map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))
#+end_src

#+RESULTS:
: ((65 40 20) (66 40 240) (67 40 460) (68 80 20) (69 80 240) (70 80 460) (71 120 20) (72 120 240) (73 120 460))

#+begin_src clojure :results value scalar
(map (fn [coll] (apply + coll)) (map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x))))
#+end_src

#+RESULTS:
: (125 346 567 168 389 610 211 432 653)

#+begin_src clojure :results value scalar
(map (fn [coll] (apply #(q/text (str (char (first coll)) (second coll) (third coll))))) (map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x))))
#+end_src

Does nothing
#+begin_src clojure :results silent
  ;; not really
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup (fn [] (do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		      (dorun (map
			      (fn [coll] (apply #(q/text (str (char (first coll)) (second coll) (nth coll 2)))))
			      (map #(cons %1 %2) (range 65 75) (for [y [40 80 120] x [20 240 460]] (vector y x)))) ))))
#+end_src
**** Three dots and complains
#+begin_src clojure :results silent
  ;; hmm
  (q/defsketch rows-of-dots
    :size [480 120]
    :setup (fn [] (do (q/stroke-weight 8)
		      (dorun (map (fn [coll]
				    (apply q/point coll))
				  (for [y [40 80 120] x [20 240 460]] (vector y x)))))))
#+end_src


#+begin_src clojure :results silent
  ;; ohh
  (q/defsketch rows-of-dots
    :size [480 240]
    :setup (fn [] (do (q/stroke-weight 8)
		      (dorun (map (fn [coll]
				    (apply q/point coll))
				  (for [y [40 80 120] x [20 240 460]] (vector x y)))))))
#+end_src
**** rows and grids with ~map~ function (mostly problems)
#+begin_src clojure :results silent
  ;; ahh! something
  (q/defsketch rows-of-dots
    :size [480 240]
    :setup (fn [] (do (q/stroke-weight 8)
		      (dorun (map (fn [coll]
				    (apply q/point coll))
				  (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))))))
#+end_src

A problem with parens?
#+begin_src clojure :results silent

  (q/defsketch rows-of-letterz
    :size [480 240]
    :setup (fn [] (do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		      (dorun (map (fn [coll]
				    (apply #(q/text (str (char %1)) %2 %3) coll)
				    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch lettur
    :size [480 240]
    :setup (fn [] (do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		      (q/text "A" 80 120))))

#+end_src


Nothing
#+begin_src clojure :results silent

  (q/defsketch rows-of-letterz
    :size [480 240]
    :setup (fn [] (dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
			 (map (partial #(q/text (str (char (first %))) (second %) (nth % 2)))
			      (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))
			 )))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch a-lettur
    :size [480 240]
    :setup #(dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
			 (map (partial (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))
			      (map (fn add-to [n xs] (cons n xs)) (range 65 75) (for [y (range 20 220 20) x (range 20 460 20)] (vector x y)))
			 )))
#+end_src

#+begin_src clojure :results silent

  (q/defsketch no-lettur-with-doruns
    :size [480 240]
    :setup #(dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun

		 (map
		  (partial
		   (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))

		  (dorun
		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 65 75)
		    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))
		(q/background 0)))
#+end_src
** doesn't use the font created with create-font?? (using :draw)
#+begin_src clojure :results silent
;;; uhhhh, ok

  (q/defsketch no-lettur-with-doruns
    :size [480 240]
    :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw #(dorun

		 (map
		  (partial
		   (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 65 75)
		    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))
#+end_src

Don't call me plezz
#+begin_src clojure :results silent
;;; uhhhh, very bad to put text-font in draw??

  (q/defsketch no-lettur-with-doruns
    :size [480 240]
    :setup #(do (q/background 0))
    :draw #(dorun (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
    
		 (map
		  (partial
		   (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 65 75)
		    (for [y (range 20 220 20) x (range 20 460 20)] (vector x y))))))
#+end_src
** Basically reproduces original drawing template (missing color changes)!
Uses a ~dorun~ in ~setup~ to create a complicated ~map~-ing scheme with anonymous functions

#+begin_src clojure :results silent
;; still complains
(q/defsketch something
  :size [660 360]
  :setup #(do (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
                 (dorun

		  (map
		   (partial
		    (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 35 127)
		    (for [y (range 40 360 46) x (range 40 640 46)] (vector x y)))))))
#+end_src


Set the background color to black and accurately replicate the "gap" and "margins" of the original
#+begin_src clojure :results silent
;; still complain
(q/defsketch something
  :size [640 360]
  :setup #(do (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
                 (dorun

		  (map
		   (partial
		    (fn do-it [coll] (q/text (str (char (first coll))) (second coll) (nth coll 2))))


		   (map
		    (fn add-to [n xs] (cons n xs))
		    (range 35 127)
		    (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y)))))))
#+end_src

Changes fill-stroke, and uses destructuring names, but all is not well

#+begin_src clojure :results silent
  (q/defsketch something
    :size [640 360]

    :setup #(do (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24))
		(dorun

		 (map
		  (partial
		   (fn do-it [[letter x y]] 
		     (do 
		       (q/fill 255, 204, 0)
		       (q/text (str (char letter)) x y))))

		  (map
		   (fn add-to [n xs] (cons n xs))
		   (range 35 127)
		   (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y)))))))
#+end_src

Running the text-drawing block from within draw somehow fails to load the font and the ~translate~ values
#+begin_src clojure :results silent
  (q/defsketch wrong-number-of-args-passed-fn
    :size [640 360]
    :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
    :setup #(do (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw 
    (fn [state] 
      (dorun
       (map
	(partial
	 (fn do-it [[letter x y]] 
	   (do
	      (q/fill 255, 204, 0)
	    (q/text (str (char letter)) x y))))


	(map
	 (fn add-to [n xs] (cons n xs))
	 (range 35 127)
	 (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y)))))))
#+end_src

#+begin_src clojure :results output
  (q/defsketch wrong-number-of-args-passed-fn
    :size [640 360]
    :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
    :setup (fn [] (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
    :draw

      (fn my-draw [& rest ]
      (dorun
      (map

	(partial
	 (fn do-it [[letter x y]] 
	   (q/text (str (char letter)) x y)))

	(map
	 (fn add-to [n xs] (cons n xs))
	 (range 35 127)
	 (for [y (range 0 (- 360 46) 46) x (range 0 (- 640 46) 46)] (vector x y))))))
    )
#+end_src

#+RESULTS:

If you include fun-mode, you need to pass state!!??
* using ~doseq~ for side-effects?

** simpler examples
*** draw points
#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/stroke-weight 8) 
:draw #(doseq [x (range 40 480 10)] (q/point x 40))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

*** Animates random "points"
#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(do (q/frame-rate 1) (q/stroke-weight 8))
:draw #(do (q/background 255) (doseq [x (range 40 480 10)] (q/point x (q/random 10 110))))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

*** lots of small points
#+begin_src clojure
;; succeeds!
(q/defsketch diagonals1
:size [480 120]
:setup #(do (q/frame-rate 1) (q/stroke-weight 2))
:draw #(do (q/background 230) (doseq [x (range 0 (q/width))] (q/point x (q/random 10 110))))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

*** lots of ellipses time
#+begin_src clojure :results silent
(q/defsketch diagonals1
:size [480 120]
:setup #(q/ellipse 132, 82, 200, 200))
#+end_src

#+begin_src clojure :results silent
(q/defsketch diagonals1
:size [480 120]
:setup #(q/smooth) 
:draw #(q/ellipse 132, 82, (* (q/random 1) 200), (* (q/random 1) 200)))
#+end_src


#+begin_src clojure
;; wigging out with random colors in the draw!
(q/defsketch diagonals1
:size [480 120]
;; :setup #(q/stroke-weight 1) 
:setup #(q/ellipse-mode (rand-nth [:center]))
:draw #(doseq [x (range 40 480 20)] (q/fill (q/random 255)) (q/ellipse x 40 20 20))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1


#+begin_src clojure
  ;; wigging out with random colors in the draw!
  (q/defsketch diagonals1
  :size [480 120]
  :setup #(q/frame-rate 1) ;; #(q/ellipse-mode (rand-nth [:radius :center :corner]))
  :draw #(dorun (do (for [y (range 0 120 10) x (range 0 480 10)] (doseq [n (range 20)] ;; (q/fill (q/random 255))
								    (q/ellipse x y n n)))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure
;; definitely not wigging out (boring random ellipses)
  (q/defsketch diagonals1
  :size [480 120]
  :setup #(q/frame-rate 1) ;; #(q/ellipse-mode (rand-nth [:radius :center :corner]))
  :draw #(dorun (do (q/background 255) (q/ellipse 20 20 (q/random 10 20) 10)))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

** drawing many ellipses with random values
#+begin_src clojure
;; wigging out with random colors and (random-ellipse mode transformations) in the draw!
(q/defsketch diagonals1
:size [480 120]
:setup #(q/ellipse-mode (rand-nth [:radius :center :corner]))
:draw #(doseq [n (range 10) y (range 0 120 20 ) x (range 0 480 20)] (q/fill (q/random 255)) (q/ellipse x y n n))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure
;; slower wigging out with random colors in the draw!
(q/defsketch diagonals1
:size [480 120]
:setup #(do (q/smooth) (q/ellipse-mode (rand-nth [:radius :center :corner])) (q/frame-rate 10))
:draw #(doseq [n (range 10) y (range 0 120 20 ) x (range 0 480 20)] (q/fill (q/random 255)) (q/ellipse x y n n))
)
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/diagonals1

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [state] (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120))))
      ))
#+end_src

#+RESULTS:

#+begin_src clojure :results output
;; will fail if you remove "state" argument but still include fun-mode middleware
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [] (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120))))
      ))
#+end_src

#+RESULTS:

#+begin_src clojure :results silent
;; basically succeeds if you remove fun-mode middleware
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [] (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120))))
      ))
#+end_src

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/translate 40, 40) (q/background 0)))
      :draw (fn my-draw [state] (do (q/fill (q/random 255)) (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 120)))))
      ))
#+end_src

#+RESULTS:

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/background 0)))
      :draw (fn my-draw [state] (do (apply q/translate (repeatedly 2 #(q/random 20 320))) (q/fill (q/random 255)) (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 40)))))
      ))
#+end_src

#+RESULTS:

#+begin_src clojure :results output
;; whoa, randomness   
 (q/defsketch wrong-number-of-args-passed-fn
      :size [640 360]
      :middleware [quil.middleware/fun-mode quil.middleware/pause-on-error]
      :setup (fn my-setup [] (do (q/background 0)))
      :draw (fn my-draw [state] (do (q/translate (q/random 20 600) (q/random 20 320)) (q/fill (q/random 255)) (dorun (apply q/ellipse (repeatedly 4 #(q/random 20 40)))))
      ))
#+end_src

#+RESULTS:

trying out pause-on-error with rows-of-dots
#+begin_src clojure
  ;; succeeds! (IN SPITE OF ITSELF!) (must have fun-mode turned-off)
  (q/defsketch rows-of-dots
  :size [480 120]
  :middleware [quil.middleware/pause-on-error]
  :setup #(q/stroke-weight 8) 
  :draw (fn [] (dorun (for [x (range 0 480 20)]
		  (dorun (for [y (range 0 120 40)] (q/point x y))))))
  )
#+end_src

#+RESULTS:
: #'quilbabel.dynamic/rows-of-dots

** try to replicate "alphabet" example
#+begin_src clojure :results silent
;; paints all sectors with all characters
(q/defsketch doseqs-pleazz
:size [640 360]
:middleware [quil.middleware/pause-on-error]
:setup (fn my-setup [] (q/translate 40, 40) (q/background 0) (q/text-font (q/create-font "data/SourceCodePro-Regular.ttf" 24)))
:draw #(dorun (for [y (range 0 360 35) x (range 0 640 35)] (doseq [n (range 35 110)] (q/text (str (char n)) x y))))
)
#+end_src





* test out update functions with fun-mode
Will need to have "m" (as opposed to "quil.middleware"), ya know, =active= somehow.

#+begin_src clojure :results output
(clojure.repl/doc m/fun-mode)
#+end_src

#+RESULTS:
: -------------------------
: quil.middleware/fun-mode
: ([options])
:   Introduces function mode. Adds 'update' function which takes current
:   state and returns new state. Makes all other functions (setup, draw,
:   mouse-click, etc) state-aware. See wiki for more details.

#+begin_src clojure :results value
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.dynamic]

** circle simply gets bigger with ~inc~ update of radius
#+begin_src clojure :results silent 
;; use update with inc to get bigger
    (q/defsketch diagonals1
    :size [480 120]
    :setup #(do (q/frame-rate 10) {:x 0 :y 0 :r 1})
    :draw (fn my-draw [state] (q/background 255) (q/ellipse 20 20 (:r state) (:r state)))
    :update (fn my-update [state] (update-in state [:r] inc))
    :middleware [m/fun-mode m/pause-on-error]
  )
#+end_src
** moves diagonally 
#+begin_src clojure :results silent
  ;; map-range using sin values
  (q/defsketch diagonals1
    :size [480 120]
    :setup #(do (q/ellipse-mode :corner) (q/frame-rate 30) {:x 0 :y 0 :r 1})
    :draw (fn my-draw [state]
	    (q/background 255)
	    (q/ellipse (q/map-range (q/sin (:r state)) -1 1 0 (- (q/width) 30)), 
		       (q/map-range (q/sin (:r state)) -1 1 0 (- (q/height) 30)), 30, 30))
    :update (fn my-update [state] (update-in state [:r] #(+ 0.1 %)))
    :middleware [m/fun-mode m/pause-on-error]
    )
#+end_src
** Uses randomness to change ~counter~ updating amount of black circle
#+begin_src clojure :results silent
    ;; map-range using sin values
    (q/defsketch diagonals1
      :size [840 120]
      :setup #(do (q/ellipse-mode :corner) (q/frame-rate 30) {:x 0 :y 0 :counter1 1 :counter2 1 :radius 30 :noiz 1 })
      :draw (fn my-draw [state]
  (q/fill 10)
	      (q/background 255)
	      (q/ellipse (q/map-range (q/sin (:counter1 state)) -1 1 0 (- (q/width) 30)), 
			 (q/map-range (q/sin (:counter1 state)) -1 1 0 (- (q/height) 30)), 
			 (:radius state), 
			 (:radius state))
  (q/fill 255)
	      (q/ellipse (q/map-range (q/sin (:counter2 state)) -1 1 0 (- (q/width) 30)), 
			 (q/map-range (q/sin (:counter2 state)) -1 1 0 (- (q/height) 30)), 
			 (:radius state), 
			 (:radius state))
)
      :update (fn my-update [state]
		(update state :counter1 #(+ (* 0.5 (rand)) 0.1 %))
		;; (update state :counter2 #(+ (* 0.1 (rand)) 0.1 %))
		;; (update state :noiz #(+ (rand) %))
		)
      :middleware [m/fun-mode m/pause-on-error]
      )
#+end_src
** uses reduce for same basic diagonal
#+begin_src clojure :results silent
    ;; map-range using sin values
    (q/defsketch diagonals1
      :size [840 120]
      :setup #(do (q/ellipse-mode :corner) (q/frame-rate 30) {:counter1 1 :counter2 (* 10 (rand)) :radius 30 })
      :draw (fn my-draw [state]
  (q/fill 10)
	      (q/background 255)
	      (q/ellipse (q/map-range (q/sin (:counter1 state)) -1 1 0 (- (q/width) 30)), 
			 (q/map-range (q/sin (:counter1 state)) -1 1 0 (- (q/height) 30)), 
			 (:radius state), 
			 (:radius state))
  (q/fill 255)
	      (q/ellipse (q/map-range (q/sin (:counter2 state)) -1 1 0 (- (q/width) 30)), 
			 (q/map-range (q/sin (:counter2 state)) -1 1 0 (- (q/height) 30)), 
			 (:radius state), 
			 (:radius state))
)
      :update (fn my-update [state]
		(reduce (fn [m k] (update-in m [k] #(+ % 0.1 ))) state [:counter2] )
		)
      :middleware [m/fun-mode m/pause-on-error]
      )
#+end_src
** uses ~reduce~ on multiple keys (to get both circles moving)
#+begin_src clojure :results silent
    ;; map-range using sin values
    (q/defsketch diagonals1
      :size [840 120]
      :setup #(do (q/ellipse-mode :corner) (q/frame-rate 30) {:x (q/random 20 40) :y (q/random 10 30) :counter1 1 :counter2 1 :radius 30})
      :draw (fn my-draw [state]
  (q/fill 10)
	      (q/background 255)
	      (q/ellipse (q/map-range (q/sin (:counter1 state)) -1 1 0 (- (q/width) 30)), 
			 (q/map-range (q/sin (:counter1 state)) -1 1 0 (- (q/height) 30)), 
			 (:radius state), 
			 (:radius state))
  (q/fill 255)
	      (q/ellipse (+ (:x state) (q/map-range (q/sin (:counter2 state)) -1 1 0 (- (q/width) 30))), 
			 (+ (:y state) (q/map-range (q/sin (:counter2 state)) -1 1 0 (- (q/height) 30))), 
			 (:radius state), 
			 (:radius state))
)
      :update (fn my-update [state]
		(reduce (fn update-all [m k] (update-in m [k] #(+ 0.1 %))) state [:counter1 :counter2] )
		)
      :middleware [m/fun-mode m/pause-on-error]
      )
#+end_src
* various file and i/o
** failed file loading
:setup #(do (q/load-image "shapez1.jpg") (q/image "shapez1.jpg" 20, 40))
** you can live reload quite easily!
#+begin_src clojure :results silent
(q/defsketch imagey
:size [480, 240]
:middleware [m/pause-on-error]
:setup setup
:draw draw
  )
#+end_src

#+begin_src clojure :results silent
(defn setup []
  "Runs once."
  (q/smooth)
  (q/no-stroke)
  (q/fill 226)
  (q/frame-rate 10))
#+end_src

#+begin_src clojure :results silent
  (defn draw
    "Example usage of with-translation and with-rotation."
    []
    (q/background-float 125)
  ;; (q/load-image "shapez1.jpg")
  (q/image (q/load-image "shapez1.jpg")  20, 0)
  )
#+end_src

#+begin_src clojure :results silent
  (defn draw
    "Example usage of with-translation and with-rotation."
    []
    (q/background-float 125)
    (let [pic1 (q/load-image "shapez1.jpg")
	  pic2 (q/load-image "shapez-0002.jpg")]
      (q/image pic1 20, 0)
      (q/image pic2 140, 0)
      ))
#+end_src
** draw with mouse
#+begin_src clojure :results silent
(q/defsketch mousey
:size [480, 120]
:middleware [m/pause-on-error]
:setup #(do (q/fill 0, 102) (q/no-stroke))
:draw #(q/ellipse (q/mouse-x) (q/mouse-y), 9, 9)
)
#+end_src

#+begin_src clojure :results silent
(q/defsketch mousey
:size [480, 120]
:middleware [m/pause-on-error]
:draw #(do (q/background 204) (q/line 20, 20 , 220, 100)
(if (q/key-pressed?) (q/line 220, 20, 20, 100)))
)
#+end_src
** draw most recently pressed key
#+begin_src clojure :results silent
(q/defsketch keyey
:middleware [m/pause-on-error]
:size [120, 140]
:setup #(do (q/text-size 64) (q/text-align :center))
:draw #(do (q/background 0) (q/text (str (q/raw-key)) 60, 80))
)
#+end_src
** Detect a press of a "coded key" 
#+begin_src clojure :results silent
(q/defsketch keyey
:middleware [m/pause-on-error]
:size [820, 140]
:setup #(do (q/text-size 64) (q/text-align :center))
:draw #(do (q/background 0) (q/text (if (q/key-coded? (q/raw-key)) "9" (str (q/raw-key))) 60, 80))
)
#+end_src
** display the key-code as an integer (for coded keys like the arrow keys)
#+begin_src clojure :results silent
(q/defsketch keyey
:middleware [m/pause-on-error]
:size [820, 140]
:setup #(do (q/text-size 64) (q/text-align :center))
:draw #(do (q/background 0) (q/text (if (q/key-coded? (q/raw-key)) (str (q/key-code)) (str (q/raw-key))) 60, 80))
)
#+end_src

All is not quite right here!
#+begin_src clojure :results silent
  (q/defsketch keyey
    :middleware [m/pause-on-error]
    :size [820, 140]
    :setup #(do (q/text-size 64) (q/text-align :center))
    :draw #(let [pic1 (q/load-image "shapez1.jpg")
		 pic2 (q/load-image "shapez-0002.jpg")] 
	     (q/background 0) 
	     (if (q/key-pressed?)
	       (if (q/key-coded? (q/raw-key))
		 (cond (= 38 (q/raw-key)) (q/image pic1 20, 0)
		       (= 39 (q/raw-key)) (q/image pic2 20, 0))
		 (q/text (if (q/key-coded? (q/raw-key)) (str (q/key-code)) (str (q/raw-key))) 660, 80))))
  )


#+end_src

** conditionally draw different pictures to the screen based on key-input
#+begin_src clojure :results silent
  (q/defsketch keyey
    :middleware [m/pause-on-error]
    :size [120, 140]
    :setup #(do (q/text-size 64) (q/text-align :center))
    :draw #(let [pic1 (q/load-image "shapez1.jpg")
		 pic2 (q/load-image "shapez-0002.jpg")] 
	     (q/background 0) 
	     (if (q/key-pressed?) (cond (= "k" (str (q/raw-key))) (q/image pic1 20, 0)
					(= "j" (str (q/raw-key))) (q/image pic2 20, 0))
		 )))



#+end_src
** get the pixel array for letters
#+begin_src clojure :results silent
(q/defsketch keyey
:middleware [m/pause-on-error]
:size [120, 120]
:setup #(do (q/text-size 64) (q/text-align :center) (q/text "a" (* 0.5 (q/width)) (* 0.5 (q/height))))
)

#+end_src

#+begin_src clojure :results silent
(q/defsketch keyey
:middleware [m/pause-on-error]
:size [120, 120]
:setup #(do (q/text-size 64) (q/text-align :center) (q/text "a" (* 0.5 (q/width)) (* 0.5 (q/height)))
(q/load-pixels) (def pxls (q/pixels))
)
)

#+end_src
* [#A] use midi controller with overtone
  :PROPERTIES:
  :ID:       27C68FBA-CA88-4F80-AA6A-D73BD4006117
  :END:
** test and debug MIDI controller (debug-on)
Why is overtone not always immediately available once "used" in the repl?

#+begin_src clojure :results value
*ns*
#+end_src

#+RESULTS:
: #namespace[quilbabel.core]

#+begin_src clojure :results silent
(in-ns 'quilbabel.core)
#+end_src

#+begin_src clojure :results value
*ns*
#+end_src

#+BEGIN_SRC clojure :results silent
(event-debug-on)
#+END_SRC

** Pad events
#+begin_src clojure :results silent
event:  [:midi :note-on] ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x268ac78a "com.sun.media.sound.FastShortMessage@268ac78a"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681399660, :velocity 127, :velocity-f 1.0}) 
event:  [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0] ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x268ac78a "com.sun.media.sound.FastShortMessage@268ac78a"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681399660, :velocity 127, :velocity-f 1.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-on 40) ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x268ac78a "com.sun.media.sound.FastShortMessage@268ac78a"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681399660, :velocity 127, :velocity-f 1.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-on) ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x268ac78a "com.sun.media.sound.FastShortMessage@268ac78a"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681399660, :velocity 127, :velocity-f 1.0})
 
event:  [:midi :note-off] ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x296de226 "com.sun.media.sound.FastShortMessage@296de226"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681522587, :velocity 0, :velocity-f 0.0}) 
event:  [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0] ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x296de226 "com.sun.media.sound.FastShortMessage@296de226"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681522587, :velocity 0, :velocity-f 0.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-off 40) ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x296de226 "com.sun.media.sound.FastShortMessage@296de226"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681522587, :velocity 0, :velocity-f 0.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-off) ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x296de226 "com.sun.media.sound.FastShortMessage@296de226"], :note 40, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 40, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 289681522587, :velocity 0, :velocity-f 0.0})
#+end_src

** Keyboard event
#+begin_src clojure :results silent
event:  [:midi :note-on] ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0xd3a052a "com.sun.media.sound.FastShortMessage@d3a052a"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020673088, :velocity 127, :velocity-f 1.0}) 
event:  [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0] ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0xd3a052a "com.sun.media.sound.FastShortMessage@d3a052a"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020673088, :velocity 127, :velocity-f 1.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-on 60) ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0xd3a052a "com.sun.media.sound.FastShortMessage@d3a052a"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020673088, :velocity 127, :velocity-f 1.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-on) ({:data2 127, :command :note-on, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0xd3a052a "com.sun.media.sound.FastShortMessage@d3a052a"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 1.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020673088, :velocity 127, :velocity-f 1.0})
 
event:  [:midi :note-off] ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x30b2b93e "com.sun.media.sound.FastShortMessage@30b2b93e"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020740010, :velocity 0, :velocity-f 0.0}) 
event:  [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0] ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x30b2b93e "com.sun.media.sound.FastShortMessage@30b2b93e"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020740010, :velocity 0, :velocity-f 0.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-off 60) ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x30b2b93e "com.sun.media.sound.FastShortMessage@30b2b93e"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020740010, :velocity 0, :velocity-f 0.0})
 
event:  (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0 :note-off) ({:data2 0, :command :note-off, :channel 0, :msg #object[com.sun.media.sound.FastShortMessage 0x30b2b93e "com.sun.media.sound.FastShortMessage@30b2b93e"], :note 60, :dev-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :status :note-on, :data1 60, :data2-f 0.0, :device {:description "Axiom A.I.R. Mini32 MIDI", :vendor "M-Audio", :sinks 0, :sources 2147483647, :name "MIDI", :transmitter #object[com.sun.media.sound.MidiInDevice$MidiInTransmitter 0x3e582327 "com.sun.media.sound.MidiInDevice$MidiInTransmitter@3e582327"], :overtone.studio.midi/full-device-key [:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0], :info #object[com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x246b2166 "MIDI"], :overtone.studio.midi/dev-num 0, :device #object[com.sun.media.sound.MidiInDevice 0x2025f9a4 "com.sun.media.sound.MidiInDevice@2025f9a4"], :version "Unknown version"}, :timestamp 290020740010, :velocity 0, :velocity-f 0.0})
#+end_src

** debug-off
#+BEGIN_SRC clojure :results silent
(event-debug-off)
#+END_SRC

** "println" event-handlers for control-change and note-on events
#+begin_src clojure :results silent
   (on-event [:midi :control-change]
             (fn [{cc-channel :note vel :velocity chan :channel}]
	       (println (list cc-channel vel chan)))
	       ::list-all-cc)
#+end_src

#+begin_src clojure :results silent
   (on-event [:midi :note-on]
             (fn [{pad :note vel :velocity}]
	       (println (list pad vel)))
	       ::list-all-pads)
#+end_src

 #+BEGIN_SRC clojure :results silent
 (remove-event-handler ::list-all)
 (remove-event-handler ::list-all-pads)
 #+END_SRC

** create (very shitty) circle-size controller!
Requires a state-ful atom below:
#+begin_src clojure :results silent
(def rad-atom (atom 1.0))

#+end_src

Must have started-up overtone!

#+begin_src clojure :results silent
;; relies on the ~rad-atom~ var

  (on-event [:midi :control-change]
	    (fn [{cc-channel :note vel :velocity}]
	      (case cc-channel
		1 (do (println (list cc-channel vel @rad-atom))
		      (swap! rad-atom #(+ % (* 0.01 vel))))
		2 (do (println (list cc-channel vel @rad-atom))
		      (swap! rad-atom #(- % (* 0.01 vel))))))
	    ::a-rad-swapper)

#+end_src

#+begin_src clojure :results silent
  (on-event [:midi :note-on]
	    (fn [{pad :note vel :velocity}]
	      (case pad
		;; low C on a small MIDI controller
		;; 48 (println (list pad vel (with-precision 4 @rad-atom))) 
		48 (println (list pad vel @rad-atom)) ;; use format fn, not with-precision
		36 (do (reset! rad-atom 0) (println (list pad vel @rad-atom)))
		37 (do (reset! rad-atom 0) (println (list pad vel @rad-atom)))
		38 (do (reset! rad-atom 0) (println (list pad vel @rad-atom)))
		39 (do (reset! rad-atom 0) (println (list pad vel @rad-atom)))
		40 (do (swap! rad-atom #(+ % (* 0.01 vel))) (println (list pad vel @rad-atom)))
		41 (do (swap! rad-atom #(+ % (* 0.1 vel))) (println (list pad vel @rad-atom)))
		42 (do (swap! rad-atom #(- % (* 0.01 vel))) (println (list pad vel @rad-atom)))
		43 (do (swap! rad-atom #(- % (* 0.1 vel))) (println (list pad vel @rad-atom)))
		;; 37 (do (println (list pad vel @rad-atom)) (swap! rad-atom #(- % (* 0.1 vel)))))
		))
	    ::a-pad-resetter)

#+end_src



 #+BEGIN_SRC clojure :results silent
 (remove-event-handler ::a-rad-swapper)
 (remove-event-handler ::a-pad-resetter)
 #+END_SRC

#+begin_src clojure :results silent
;; relies on a meaningful (postive) value for ~rad-atom~
  (q/defsketch diagonals1
  :size [480 120]
  :setup #(q/ellipse 132, 82, @rad-atom, @rad-atom
  ))
#+end_src

#+begin_src clojure :results silent 
;; use update with inc to get bigger
    (q/defsketch diagonals1
    :size [900 300]
    :setup #(do (q/frame-rate 10) {:x 0 :y 0 :r 1})
    :draw (fn my-draw [state] (q/background 255) (q/ellipse 20 20 (:r state) (:r state)))
    :update (fn my-update [state] (update-in state [:r] #(+ % @rad-atom)))
    :middleware [m/fun-mode m/pause-on-error]
  )
#+end_src

** improved circle-size controller
#+begin_src clojure :results silent
  (on-event [:midi :note-on]
	    (fn [{pad :note vel :velocity}]
	      (let [n (format "%.2f" @rad-atom)]
		(case pad
		  ;; highest G on small midi controller
		  79 (println (list pad n))
		  36 (do (reset! rad-atom 0.001) (println (list pad  n)))
		  37 (do (reset! rad-atom 0.001) (println (list pad  n)))
		  38 (do (reset! rad-atom 0.001) (println (list pad  n)))
		  39 (do (reset! rad-atom 0.001) (println (list pad  n)))
		  40 (do (swap! rad-atom #(+ % (* 0.01 vel))) (println (list pad vel n)))
		  41 (do (swap! rad-atom #(+ % (* 0.1 vel))) (println (list pad vel n)))
		  42 (do (swap! rad-atom #(- % (* 0.01 vel))) (println (list pad vel n)))
		  43 (do (swap! rad-atom #(- % (* 0.1 vel))) (println (list pad vel n)))
		  ;; 37 (do (println (list pad vel n)) (swap! rad-atom #(- % (* 0.1 vel)))))
		  )))
	    ::a-pad-resetter)

#+end_src

#+begin_src clojure :results silent 
;; use update with inc to get bigger
    (q/defsketch diagonals1
    :size [300 300]
    :setup #(do (q/frame-rate 10) {:x 0 :y 0 :r 1})
    :draw (fn my-draw [state] (q/background 255) (q/ellipse 150 150 (:r state) (:r state)))
    :update (fn my-update [state] (update-in state [:r] (fn [_] (identity @rad-atom))))
    :middleware [m/fun-mode m/pause-on-error]
  )
#+end_src

#+begin_src clojure :results silent
;; expect a float (which an int...is not!)
(reset! rad-atom 10.0)

;; @rad-atom
#+end_src

** control text display

*** simple
#+begin_src clojure :results silent
(q/defsketch texty
:size [480, 120]
:setup #(q/text-font (q/create-font "SourceCodePro-Regular.ttf" 24))
:draw #(do (q/text-size 48) (q/text "YO Adrian" 100, 50))
  )
#+end_src

*** develop a scrolling "ticker" example
#+begin_src clojure :results silent
(def am-str-long "It is my contention that organizing a pedagogical practice around this notion of three \"languages,\" which babble together wherever artists rely heavily on digital technology, offers better prospects for artists and the arts more generally in an age in thrall to STEM.")
(def am-str-short "It is my contention that organizing a pedagogical")
(def words (clojure.string/split am-str-long #" "))
#+end_src

#+begin_src clojure :results silent
(q/defsketch texty
:size [480, 120]
:middleware [m/pause-on-error]
:setup #(q/text-font (q/create-font "Arial" 24))
:draw #(do (q/text-size 48) (q/text am-str-long 100, 50))
  )
#+end_src

Works!
#+begin_src clojure :results silent
(q/defsketch texty
:size [480, 120]
:middleware [m/pause-on-error m/fun-mode]
:setup #(do (q/text-font (q/create-font "Arial" 24)) {:x 450 :y 60 :r 1})
:draw (fn my-draw [state] (q/background 128) (q/text-size 48) (q/text am-str-short (:x state) (:y state)))
:update (fn my-update [state] (update-in state [:x] #(- % (:r state))))
  )
#+end_src

*** use atoms and controller


#+begin_src clojure :results silent
(def rate (atom 0.1))

#+end_src

#+begin_src clojure :results silent
;; requires a loaded string (in ~am-str-long~)
(q/defsketch texty
:size [480, 120]
:middleware [m/pause-on-error m/fun-mode]
:setup #(do (q/text-font (q/create-font "Arial" 24)) {:x 450 :y 60 :r @rate})
:draw (fn my-draw [state] (q/background 128) (q/text-size 48) (q/text am-str-long (:x state) (:y state)))
:update (fn my-update [state] (update-in state [:x] #(- % (* 0.1 @rate))))
  )
#+end_src

#+begin_src clojure :results silent
  (on-event [:midi :note-on]
	    (fn [{pad :note vel :velocity}]
	      (let [n (format "%.2f" @rate)]
		(case pad
		  79 (println (list pad n))
		  36 (do (reset! rate 0.001) (println (list pad n)))
		  37 (do (reset! rate 0.001) (println (list pad n)))
		  38 (do (reset! rate 0.001) (println (list pad n)))
		  39 (do (reset! rate 0.001) (println (list pad n)))
		  40 (do (swap! rate #(+ % (* 0.01 vel))) (println (list pad vel n)))
		  41 (do (swap! rate #(+ % (* 0.1 vel))) (println (list pad vel n)))
		  42 (do (swap! rate #(- % (* 0.01 vel))) (println (list pad vel n)))
		  43 (do (swap! rate #(- % (* 0.1 vel))) (println (list pad vel n)))
		  ;; 37 (do (println (list pad vel n)) (swap! rate #(- % (* 0.1 vel)))))
		  (println "key not set")
		  )))
	    ::a-pad-resetter)

#+end_src

 #+BEGIN_SRC clojure :results silent
 (remove-event-handler ::a-pad-resetter)
 #+END_SRC

* overtone sounds

** some background noise
#+begin_src clojure :results silent
  (demo 10 (* (+ (bpf (sin-osc (+ 400 (* 100 (lf-noise1:kr)))) 400 1)
		  (pink-noise)) (+ 5 (* 0.5 (sin-osc:kr 2)))))

#+end_src


#+begin_src clojure :results silent
  (demo 60 (g-verb (sum
		    (map #(blip
			   (* (midicps
			       (duty:kr % 0 (dseq [24 27 31 36 41] INF)))
			      %2)
			   (mul-add:kr (lf-noise1:kr 1/2) 3 4))
			 [1 1/2 1/4]
			 [1 4 8]))
		   200
		   8))
#+end_src

[
[24 28 31 35 39]
[24 27 31 35 38]
#+begin_src clojure :results silent
  (demo 15 (* 0.5 (g-verb (sum
		    (map #(blip
			   (* (midicps
			       (duty:kr % 0 (dseq [24 28 31 35 38 42 45 49 52 56 59 63] INF)))
			      %2)
			   (mul-add:kr (lf-noise1:kr 0.1) 6 8))
			 [4 2 1]
			 ;; [1 1/2 1/4]
			 [1 4 8]))
			 100
		   4)))
#+end_src

* tweening

** whew, finally

*** practicing reduce
Not quite tweening, but uses a (for now, complicated) reduce

#+begin_src clojure :results silent
  (q/defsketch tweens 
  :size [420, 120]
  :middleware [m/pause-on-error m/fun-mode]
  :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
	      :x 20, :y 30,
	      :step 0.005 :pct 0.0})
  :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
:update (fn my-update [state] (reduce (fn update-all [m k] (update m k #(+ % 0.5))) state [:x :y]))
  )
#+end_src

*** use a ~case~ in a reduce
Conditionally apply different version of a function in a reduce
#+begin_src clojure :results silent
    (q/defsketch tweens 
    :size [420, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
		:x 20, :y 30,
		:step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
      :update (fn my-update [state]
		(reduce (fn update-all [m k]
			  (case k
			    :x (update m k #(+ % 0.5))
			    :y (update m k #(+ % 0.1)))) state [:x :y]))
    )
#+end_src

*** change the amount you add to y in each step
Ha! Exponential falling down??
#+begin_src clojure :results silent
    (q/defsketch tweens 
    :size [420, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
		:x 20, :y 30,
		:step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
      :update (fn my-update [state]
		(reduce (fn update-all [m k]
			  (case k
			    :x (update m k #(+ % 0.5))
			    :y (update m k #(+ % (:pct state)))
			    (update m k #(+ % 0.01)))) state [:x :y :pct]))
    )
#+end_src

*** try to replicate full steps of original
#+begin_src clojure :results silent
    (q/defsketch tweens 
    :size [620, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
		:x 20, :y 30,
		:step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
      :update (fn my-update [state]
		(reduce (fn update-all [m k]
			  (case k
			    :x (update m k (fn x-update [_] (+ (:start-x state) (* (- (:stop-x state) (:start-x state)) (:pct state)))))
			    :y (update m k (fn y-update [_] (+ (:start-y state) (* (- (:stop-y state) (:start-y state)) (:pct state)))))
			    (update m k #(+ % (:step state))))) state [:x :y :pct]))
    )
#+end_src

Hmm, problems occur once pct reaches 1.0?
#+begin_src clojure :results silent
  (q/defsketch tweens 
    :size [620, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
					      :x 20, :y 30,
					      :step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
    :update (fn my-update [state]
	      (if (< (:pct state) 1.0) 
		(reduce (fn update-all [m k]
			  (case k
			    :x (update m k (fn x-update [_] (+ (:start-x state) (* (- (:stop-x state) (:start-x state)) (:pct state)))))
			    :y (update m k (fn y-update [_] (+ (:start-y state) (* (- (:stop-y state) (:start-y state)) (:pct state)))))
			    (update m k #(+ % (:step state))))) state [:x :y :pct])
(q/ellipse (:x-stop state) (:y-stop state) 20 20)))
    )
#+end_src

Without update, will just statically draw
#+begin_src clojure :results silent
  (q/defsketch tweens 
    :size [620, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
					      :x 20, :y 30,
					      :step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
    ;; :update (fn my-update [state] (q/ellipse (:x state) (:y state) 20 20))
    )
#+end_src

#+begin_src clojure :results silent
  (q/defsketch tweens 
    :size [620, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
					      :x 20, :y 30,
					      :step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
    :update (fn my-update [state] (identity state))
    )
#+end_src


Two cheers for ~identity~!
#+begin_src clojure :results silent
  (q/defsketch tweens 
    :size [620, 120]
    :middleware [m/pause-on-error m/fun-mode]
    :setup (fn my-setup [] (q/frame-rate 60) {:start-x 20, :start-y 30, :stop-x 160, :stop-y 80,
					      :x 20, :y 30,
					      :step 0.005 :pct 0.0})
    :draw (fn my-draw [state] (do (q/background 0) (q/ellipse (:x state) (:y state) 20 20)))
    :update (fn my-update [state]
	      (if (< (:pct state) 1.0) 
		(reduce (fn update-all [m k]
			  (case k
			    :x (update m k (fn x-update [_] (+ (:start-x state) (* (- (:stop-x state) (:start-x state)) (:pct state)))))
			    :y (update m k (fn y-update [_] (+ (:start-y state) (* (- (:stop-y state) (:start-y state)) (:pct state)))))
			    (update m k #(+ % (:step state))))) state [:x :y :pct])
		(identity state)))
    )
#+end_src

* use a suite of stateful atoms within a range
  :PROPERTIES:
  :ID:       083FE0B8-6343-4643-9253-B69356F00257
  :END:

** four "changeable constants"
  #+begin_src clojure :results silent
(def tenths (atom 0.1))
(def ones (atom 1))
(def tens (atom 10))
(def hundreds (atom 100))

  #+end_src


  #+begin_src clojure :results silent
(def smn (atom 0))
(def val (atom 0))
  #+end_src

** create a cycle-able atom
  #+begin_src clojure :results silent
(mod (swap! smn inc) 3)
  #+end_src

#+begin_src clojure :results silent
  (on-event [:midi :note-on]
	    (fn [{pad :note vel :velocity}]
	      (case pad
		36 (do (println (list pad @ones)) (reset! ones (#(mod (swap! ones inc) 10))))
		;; 37 (do (println (list pad @val)) (reset! val ((fn uppdr [] (mod (swap! tens #(* 10 (inc %))) 100)))))
		37 (do (println (list pad @tens)) (reset! tens (mod (swap! tens #(+ 10 %)) 100)))
		38 (do (println (list pad @hundreds)) (reset! hundreds (mod (swap! hundreds #(+ 100 %)) 1000)))
		))
	    ::a-pad-cycler)

#+end_src

  #+begin_src clojure :results silent
(remove-event-handler ::a-pad-cycler)
  #+end_src



** draw some
  #+begin_src clojure :results silent
(defn draw [] (q/ellipse 100 100 20 20))

(q/defsketch draah :title "draah" :size [400 400]
  :draw draw
)


  #+end_src

  #+begin_src clojure :results silent
(defn draw [] (do (q/background 0) (q/ellipse 100 100 20 20)))

  #+end_src

  #+begin_src clojure :results silent
(defn draw [] (do (q/background 0) (q/ellipse 50 50 (+ 100 @ones @tens @hundreds) (+ 100 @ones @tens @hundreds))))
  #+end_src

  #+begin_src clojure :results silent
(defn draw [] (do (q/background 0) (q/ellipse (+ 50 @ones @tens) (+ 50 @ones @tens) 20 20)))
  #+end_src

* swap in and out multiple Generative Art Draws
** some custom functions in origian gen_art 19
#+BEGIN_SRC clojure :results silent :show-process t
(defn mk-lines-stream
    []
    (let [half-width   (/ (q/width) 1.1)
	  half-height  (/ (q/height) 1.1)
	  radius-steps (s/steps (q/random 10) 0.005)
	  angle-steps  (s/steps (q/random 10) 0.005)
	  x-steps      (s/steps (q/random 10) 0.01)
	  x-noises     (map q/noise x-steps)
	  y-steps      (s/steps (q/random 10) 0.01)
	  y-noises     (map q/noise y-steps)
	  angle-noises (map q/noise angle-steps)
	  angle-noises (c/mul-add angle-noises 6 -3)
	  angles       (s/steps (- (/ q/PI 2)) angle-noises)
	  angles       (map #(mod % 360) angles)
	  rads         (map q/radians angles)
	  center-xs    (c/mul-add x-noises 100 (- half-width 50))
	  center-ys    (c/mul-add y-noises 100 (- half-height 50))
	  radii        (map q/noise radius-steps)
	  radii        (c/mul-add radii 550 1)
	  cos-rads     (map q/cos rads)
	  sin-rads     (map q/sin rads)
	  opp-rads     (map #(+ q/PI %) rads)
	  cos-opp-rads (map q/cos opp-rads)
	  sin-opp-rads (map q/sin opp-rads)
	  x1s          (c/mul-add cos-rads radii center-xs)
	  y1s          (c/mul-add sin-rads radii center-ys)
	  x2s          (c/mul-add cos-opp-rads radii center-xs)
	  y2s          (c/mul-add sin-opp-rads radii center-ys)
	  lines        (map list x1s y1s x2s y2s)]
      (s/seq->stream lines)))

#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
  (defn mk-cols-stream
    []
    (let [stroke-cols (s/cycle-between 0 255)]
      (s/seq->stream stroke-cols)))

#+END_SRC

** originally used set-state! and pulled a few :key-values out of "state"
#+BEGIN_SRC clojure :results silent :show-process t
    (defn setup []
      (q/frame-rate 24)
      (q/smooth)
      (q/background 180)
      (q/stroke 0)
      (q/stroke-weight 1)
      (q/no-fill)
      ;; (q/set-state! 
      ;;  :lines-str (mk-lines-stream)
      ;;  :cols-str (mk-cols-stream)
      ;;  :diam (atom 10)
      ;;  :cent-x (/ (q/width) 2)
      ;;  :cent-y (/ (q/height) 2))
  )
#+END_SRC

** initial non-looping draw
#+BEGIN_SRC clojure :results silent :show-process t
(defn draw []
    (let [cent-x (q/state :cent-x)
	  cent-y (q/state :cent-y)
	  diam   (q/state :diam)]
      (when (<= @diam 1000)
	(q/ellipse cent-x cent-y @diam @diam)
	(swap! diam + 1.0))))
#+END_SRC

** looping draw
#+BEGIN_SRC clojure :results silent :show-process t

  (defn draw []
    (let [lines-str (q/state :lines-str)
	  cols-str  (q/state :cols-str)
	  line-args (lines-str)
	  col       (cols-str)]
      (q/stroke col 60)
      (apply q/line line-args)))
#+END_SRC

** attempt to reset state using separate call to set-state!

#+BEGIN_SRC clojure :results silent :show-process t
    (q/set-state! 
     :lines-str (mk-lines-stream)
     :cols-str (mk-cols-stream)
     :diam (atom 10)
     :cent-x (/ 500 2)
     :cent-y (/ 300 2))
#+END_SRC
** call defsketch to make sketch
#+BEGIN_SRC clojure :results silent :show-process t
  (q/defsketch my-prezi
    :title "Concentric Circles"
    :setup setup
    :draw draw
    :middleware [m/pause-on-error]
    :size [500 300])
#+END_SRC
** can start with empty draw and setup (x) functions (?!)
#+BEGIN_SRC clojure :results silent :show-process t
(defn setup [])
(defn draw [])
#+END_SRC
** original separate setups
#+BEGIN_SRC clojure :results silent :show-process t
  (defn setup []
    (q/smooth)
    (q/frame-rate 30)
    (q/background 255)
    (q/no-fill)
    (q/stroke-weight 3)
    (q/set-state! :lines-str (mk-lines-stream)
		  :cols-str (mk-cols-stream)))
#+END_SRC


#+BEGIN_SRC clojure :results silent :show-process t
(defn setup []
    (q/frame-rate 24)
    (q/smooth)
    (q/background 180)
    (q/stroke 0)
    (q/stroke-weight 1)
    (q/no-fill)
    (q/set-state! :diam (atom 10)
		:cent-x (/ (q/width) 2)
		:cent-y (/ (q/height) 2)))
#+END_SRC
* basic use of toggling between multiple updates
** initial pass at bouncing betwee ~update~ functions
*** update a radius with an ~inc~ or stop it with ~identity~
#+BEGIN_SRC clojure :results silent :show-process t
(defn update [state] (update-in state [:r] inc)) 
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn update [state] (update-in state [:r] identity)) 
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn update [state] (update-in state [:r] dec)) 
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(q/defsketch drawcircles-with-fun-mode
:size[480 120]
:setup (fn [] {:x 0, :y 0, :r 10})
:draw #(q/ellipse (:x %) (:y %) (:r %) (:r %))
:update update ;; #(update-in % [:r] inc)
;; :mouse-moved (fn [m e] (-> m (assoc :x (:x e) :y (:y e)) (update-in [:r] #(max 10 (dec %)))))
:key-pressed (fn [] )
:middleware [m/fun-mode m/pause-on-error])
#+END_SRC
* convert from set-states to updates
** [#A] basic sketch with basic setup, update and draw
#+BEGIN_SRC clojure :results silent :show-process t
      (q/defsketch new-updater
	:title "Growing circle"
	:setup my_setup
	:update my_update
	:draw my_draw
	;; :features [:keep-on-top]
	:key-pressed key-pressed
	:middleware [m/fun-mode 
  m/pause-on-error
  ]
	:size [800 300]
	;; :keep-on-top true
    )
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn key-pressed [state event] (identity state))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn my_setup [] (q/frame-rate 1) {:diam 10 :frame-rate 2 :cent-x (/ (q/width) 2) :cent-y (/ (q/height) 2)})
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn my_draw [state] (q/background 180))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
  ;; (defn my_update [state] (update-in state [:diam] identity))
(defn my_update [state] (identity state ))
#+END_SRC

#+BEGIN_SRC clojure :results output :show-process t
(println @(:state (meta new-updater)))
#+END_SRC

#+RESULTS:
: {:diam 400, :frame-rate 2, :cent-x 400, :cent-y 150}

** now draw circles

# make a tiny circle, depending on :diam value?
#+BEGIN_SRC clojure :results silent :show-process t
(defn my_draw [state] (q/frame-rate (:frame-rate state)) (if (< (:diam state) 800) (do (q/background 180) (q/ellipse (:cent-x state) (:cent-y state) (:diam state) (:diam state)))))
#+END_SRC

# start making the circles bigger
#+BEGIN_SRC clojure :results silent :show-process t
(defn my_update [state] (update-in state [:diam] inc))
#+END_SRC

# and shrink again
#+BEGIN_SRC clojure :results silent :show-process t
(defn my_update [state] (update-in state [:diam] - @param1))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn my_update [state] (assoc state :diam @param6))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn my_update [state] (assoc state :diam 10))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn my_update [state] (update state :diam + @param1))
#+END_SRC

* use update to change frame-rate 
#+BEGIN_SRC clojure :results silent :show-process nil
(defn key-pressed [state event] (identity state))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process nil
(defn my_setup []  {:diam 10 :param1 @param1 :frame-rate 2 :cent-x (/ (q/width) 2) :cent-y (/ (q/height) 2)})
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process nil
  ;; (defn my_draw [state] (q/frame-rate (:frame-rate state)) (q/background 180))
  (defn my_draw [state] (q/frame-rate (:frame-rate state)) (if (< (:diam state) 1820) (do (q/background 180) (q/ellipse (:cent-x state) (:cent-y state) (:diam state) (:diam state))) (q/background 10)))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process nil
;; (defn my_update [state] (identity state ))
(defn my_update [state] (update state :diam + @param1))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
(defn my_update [state] (assoc state :frame-rate 10))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
  ;; (defn my_update [state] (do (assoc state :diam 10 :frame-rate 1 :param1 @param1) (update state :diam + @param1)))
  (defn my_update [state] (do (update state :diam + @param1)))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
;; function defined from reduce clojuredocs
  (defn my_update [state] (update-map-entries state {:diam 10 :frame-rate 1}))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process t
;; function defined from reduce clojuredocs
  (defn my_update [state] (update-map-entries state {:diam 10 :frame-rate 10}))
#+END_SRC

#+BEGIN_SRC clojure :results silent :show-process nil
      (q/defsketch change-fr
	:title "Growing circle"
	:setup my_setup
	:update my_update
	:draw my_draw
	;; :features [:keep-on-top]
	:key-pressed key-pressed
	:middleware [m/fun-mode 
  m/pause-on-error
  ]
	:size [800 300]
	;; :keep-on-top true
    )
#+END_SRC

ONLY AFTER SKETCH IS RUNNING!
#+BEGIN_SRC clojure :results output
(println @(:state (meta change-fr)))
#+END_SRC

#+RESULTS:
: {:diam 10, :param1 7.4, :frame-rate 10, :cent-x 400, :cent-y 150}


